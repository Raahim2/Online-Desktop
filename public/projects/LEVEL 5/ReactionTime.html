<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reaction Time Game</title>
    <!-- Include Tailwind CSS via CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles if needed, but Tailwind should cover most */
        #game-area {
            touch-action: manipulation; /* Prevent zoom on double tap on mobile */
        }
        #target-button {
            /* Ensure button size is accounted for in random positioning */
            min-width: 60px;
            min-height: 40px;
        }
    </style>
</head>
<body class="bg-gradient-to-br from-indigo-100 via-purple-100 to-pink-100 min-h-screen flex items-center justify-center p-4 font-sans">

    <div class="bg-white rounded-xl shadow-2xl p-6 sm:p-8 md:p-10 max-w-2xl w-full text-center">

        <h1 class="text-3xl sm:text-4xl font-bold text-gray-800 mb-4">Reaction Time Test</h1>
        <p id="status" class="text-lg text-gray-600 mb-6 h-6">Click "Start Game" to begin!</p>

        <!-- Game Area -->
        <div id="game-area" class="relative w-full h-64 sm:h-80 bg-gray-200 rounded-lg mb-6 overflow-hidden border-2 border-gray-300 shadow-inner">
            <!-- The target button will appear here -->
            <button id="target-button" class="absolute hidden bg-red-500 hover:bg-red-600 text-white font-bold py-3 px-5 rounded-full shadow-lg transform transition-all duration-100 ease-in-out focus:outline-none focus:ring-2 focus:ring-red-700 focus:ring-opacity-50 cursor-pointer">
                Click!
            </button>
        </div>

        <!-- Start Button -->
        <button id="start-button" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-8 rounded-lg shadow-md transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-blue-700 focus:ring-opacity-50 mb-6">
            Start Game
        </button>

        <!-- Results Display -->
        <div class="flex flex-col sm:flex-row justify-around items-center w-full space-y-4 sm:space-y-0 sm:space-x-4">
            <div class="bg-gray-100 p-4 rounded-lg shadow w-full sm:w-auto flex-1">
                <p class="text-sm text-gray-500 uppercase font-semibold">Last Time</p>
                <p id="last-time" class="text-2xl font-bold text-indigo-600">- ms</p>
            </div>
            <div class="bg-gray-100 p-4 rounded-lg shadow w-full sm:w-auto flex-1">
                <p class="text-sm text-gray-500 uppercase font-semibold">Average Time</p>
                <p id="average-time" class="text-2xl font-bold text-purple-600">- ms</p>
            </div>
             <div class="bg-gray-100 p-4 rounded-lg shadow w-full sm:w-auto flex-1">
                <p class="text-sm text-gray-500 uppercase font-semibold">Best Time</p>
                <p id="best-time" class="text-2xl font-bold text-pink-600">- ms</p>
            </div>
        </div>

    </div>

    <script>
        const startButton = document.getElementById('start-button');
        const targetButton = document.getElementById('target-button');
        const gameArea = document.getElementById('game-area');
        const statusDisplay = document.getElementById('status');
        const lastTimeDisplay = document.getElementById('last-time');
        const averageTimeDisplay = document.getElementById('average-time');
        const bestTimeDisplay = document.getElementById('best-time');

        let startTime = 0;
        let timeoutId = null; // To store the setTimeout reference
        let reactionTimes = []; // Array to store times for average calculation
        let bestTime = Infinity;
        let waitingForClick = false;

        function getRandomDelay(min = 1000, max = 4000) { // Delay between 1 and 4 seconds
            return Math.random() * (max - min) + min;
        }

        function getRandomPosition() {
            const areaRect = gameArea.getBoundingClientRect();
            const buttonRect = targetButton.getBoundingClientRect(); // Use actual rendered size

            // Ensure button dimensions are valid (might be 0 if hidden initially)
            const buttonWidth = targetButton.offsetWidth || 60; // Use min-width as fallback
            const buttonHeight = targetButton.offsetHeight || 40; // Use min-height as fallback

            // Calculate max possible top/left, ensuring button stays fully within area
            const maxTop = areaRect.height - buttonHeight;
            const maxLeft = areaRect.width - buttonWidth;

            // Generate random positions, ensuring they are non-negative
            const randomTop = Math.max(0, Math.random() * maxTop);
            const randomLeft = Math.max(0, Math.random() * maxLeft);

            return { top: randomTop, left: randomLeft };
        }

        function showTarget() {
            const position = getRandomPosition();
            targetButton.style.top = `${position.top}px`;
            targetButton.style.left = `${position.left}px`;

            // Change color randomly? (Optional extra visual flair)
            const colors = ['bg-red-500', 'bg-green-500', 'bg-yellow-500', 'bg-purple-500', 'bg-pink-500'];
            // Remove previous color classes before adding a new one
            targetButton.classList.remove('bg-red-500', 'bg-green-500', 'bg-yellow-500', 'bg-purple-500', 'bg-pink-500', 'hover:bg-red-600'); // Clear existing color/hover
            const randomColor = colors[Math.floor(Math.random() * colors.length)];
            targetButton.classList.add(randomColor);
            // Add corresponding hover (simple assumption based on color name)
            targetButton.classList.add(`hover:${randomColor.replace('500', '600')}`);


            targetButton.classList.remove('hidden');
            statusDisplay.textContent = 'Click!';
            statusDisplay.classList.add('text-green-600', 'font-bold');
            statusDisplay.classList.remove('text-gray-600');
            waitingForClick = true;
            startTime = Date.now(); // Record time when target appears
        }

        function calculateStats() {
            if (reactionTimes.length === 0) return { average: 0, best: Infinity };

            const sum = reactionTimes.reduce((acc, time) => acc + time, 0);
            const average = Math.round(sum / reactionTimes.length);
            const currentBest = Math.min(...reactionTimes);

            return { average, best: currentBest };
        }

        function updateDisplays(lastTime) {
            lastTimeDisplay.textContent = `${lastTime} ms`;

            const stats = calculateStats();
            averageTimeDisplay.textContent = stats.average > 0 ? `${stats.average} ms` : '- ms';

            // Update overall best time
            if (stats.best !== Infinity && stats.best < bestTime) {
                bestTime = stats.best;
            }
            bestTimeDisplay.textContent = bestTime !== Infinity ? `${bestTime} ms` : '- ms';

        }

        function resetGame(message = 'Click "Start Game" to begin!') {
            targetButton.classList.add('hidden');
            statusDisplay.textContent = message;
            statusDisplay.classList.remove('text-red-600', 'text-green-600', 'font-bold');
            statusDisplay.classList.add('text-gray-600');
            startButton.disabled = false; // Re-enable start button
            startButton.classList.remove('opacity-50', 'cursor-not-allowed');
            waitingForClick = false;
            if (timeoutId) {
                clearTimeout(timeoutId); // Clear any pending timeout
                timeoutId = null;
            }
        }

        function handleEarlyClick() {
             if (!waitingForClick && timeoutId) { // Clicked during the 'wait' phase
                clearTimeout(timeoutId);
                timeoutId = null;
                resetGame('Too soon! Click Start to try again.');
                statusDisplay.classList.add('text-red-600', 'font-bold');
                statusDisplay.classList.remove('text-gray-600');
             }
        }


        // Event Listeners
        startButton.addEventListener('click', () => {
            resetGame('Get ready...'); // Reset state before starting
            startButton.disabled = true; // Disable start button during wait
            startButton.classList.add('opacity-50', 'cursor-not-allowed');
            statusDisplay.classList.remove('text-red-600'); // Remove error color if present

            const delay = getRandomDelay();
            timeoutId = setTimeout(showTarget, delay);
        });

        targetButton.addEventListener('click', () => {
            if (!waitingForClick) return; // Ignore clicks if not waiting

            const endTime = Date.now();
            const reactionTime = endTime - startTime;

            reactionTimes.push(reactionTime);
            updateDisplays(reactionTime);
            resetGame('Nice! Click Start for the next round.');
        });

         // Optional: Detect clicks in the game area *during* the wait phase as "too soon"
         gameArea.addEventListener('click', (event) => {
            // Check if the click was on the area itself and not the button,
            // and if we are in the waiting phase (timeout is set but button not shown yet)
             if (event.target === gameArea && !waitingForClick && timeoutId) {
                 handleEarlyClick();
             }
         });

    </script>

</body>
</html>
