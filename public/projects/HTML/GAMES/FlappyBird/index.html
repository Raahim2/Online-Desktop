<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Flappy Bird</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            touch-action: manipulation; /* Prevent zooming on mobile */
            overflow: hidden; /* Prevent scrolling */
        }
        #game-container {
            width: 400px;
            height: 600px;
            background-image: linear-gradient(to bottom, #71c5cf, #a6e6e8);
            overflow: hidden;
            position: relative;
            border: 4px solid #333;
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
            margin: auto; /* Center on larger screens */
        }
        #bird {
            width: 40px;
            height: 30px;
            background-color: #facc15; /* yellow-400 */
            border-radius: 50%;
            position: absolute;
            border: 2px solid #ca8a04; /* yellow-600 */
            box-shadow: 0 3px 5px rgba(0,0,0,0.2);
            transition: transform 0.1s linear; /* Smooth rotation */
        }
        .pipe {
            position: absolute;
            width: 60px;
            background-color: #22c55e; /* green-500 */
            border: 3px solid #15803d; /* green-700 */
        }
        .pipe-top {
            bottom: 0; /* Anchored to the bottom of its container div */
        }
        .pipe-bottom {
            top: 0; /* Anchored to the top of its container div */
        }
        .pipe-pair {
             position: absolute;
             left: 100%; /* Start off screen */
             width: 60px; /* Match pipe width */
             height: 100%;
             display: flex;
             flex-direction: column;
             justify-content: space-between; /* Creates the gap */
        }
         /* Basic Heads for Pipes */
        .pipe::before {
             content: '';
             position: absolute;
             left: -5px; /* Slightly wider */
             width: 70px; /* Wider head */
             height: 25px;
             background-color: #16a34a; /* green-600 */
             border: 3px solid #15803d;
             border-radius: 5px;
        }
         .pipe-top::before {
             bottom: -3px; /* Position head at the opening */
         }
         .pipe-bottom::before {
             top: -3px; /* Position head at the opening */
         }

        .overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            color: white;
            z-index: 10;
        }
        .hidden {
            display: none;
        }
        #score {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 3rem;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            z-index: 5;
        }
    </style>
</head>
<body class="bg-gray-200 flex items-center justify-center min-h-screen select-none">

    <div id="game-container">
        <div id="score">0</div>
        <div id="bird"></div>

        <div id="start-message" class="overlay">
            <h2 class="text-4xl font-bold mb-4">Flappy Bird</h2>
            <p class="text-xl">Click or Press Space to Play</p>
        </div>

        <div id="game-over-message" class="overlay hidden">
            <h2 class="text-4xl font-bold mb-2 text-red-500">Game Over!</h2>
            <p class="text-xl mb-4">Your Score: <span id="final-score" class="font-bold">0</span></p>
            <button id="restart-button" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg text-lg transition-colors focus:outline-none focus:ring-2 focus:ring-blue-400 focus:ring-opacity-50">
                Restart
            </button>
        </div>
    </div>

<script>
    const gameContainer = document.getElementById('game-container');
    const birdElement = document.getElementById('bird');
    const scoreElement = document.getElementById('score');
    const startMessage = document.getElementById('start-message');
    const gameOverMessage = document.getElementById('game-over-message');
    const finalScoreElement = document.getElementById('final-score');
    const restartButton = document.getElementById('restart-button');

    const gameHeight = gameContainer.offsetHeight;
    const gameWidth = gameContainer.offsetWidth;
    const birdHeight = birdElement.offsetHeight;
    const birdWidth = birdElement.offsetWidth;

    let birdY = gameHeight / 2 - birdHeight / 2;
    let birdVelocity = 0;
    const gravity = 0.4;
    const flapStrength = -7; // Negative value for upward movement

    let pipes = [];
    const pipeWidth = 60;
    const pipeGap = 150; // Vertical gap between pipes
    const pipeSpeed = 3;
    let pipeSpawnTimer = 0;
    const pipeSpawnInterval = 90; // Lower number = pipes spawn more frequently

    let score = 0;
    let gameLoopInterval = null;
    let gameState = 'start'; // 'start', 'playing', 'gameover'

    function startGame() {
        birdY = gameHeight / 2 - birdHeight / 2;
        birdVelocity = 0;
        score = 0;
        pipes = [];
        gameState = 'start';

        scoreElement.textContent = score;
        gameOverMessage.classList.add('hidden');
        startMessage.classList.remove('hidden');
        birdElement.style.top = `${birdY}px`;
        birdElement.style.transform = 'rotate(0deg)';

        // Clear existing pipe elements
        document.querySelectorAll('.pipe-pair').forEach(pipe => pipe.remove());

        // Clear previous game loop if any
        if (gameLoopInterval) {
            cancelAnimationFrame(gameLoopInterval);
            gameLoopInterval = null;
        }
        // Initial render
        render();
    }

    function flap() {
        if (gameState === 'playing') {
            birdVelocity = flapStrength;
        } else if (gameState === 'start') {
            gameState = 'playing';
            startMessage.classList.add('hidden');
            birdVelocity = flapStrength;
             // Start the game loop only when the first flap occurs
             if (!gameLoopInterval) {
                 gameLoopInterval = requestAnimationFrame(gameLoop);
             }
        }
    }

    function gameLoop() {
        if (gameState !== 'playing') {
            // Don't continue the loop if not playing, but keep requesting frames
            // until restart if needed, or rely on event listeners to restart the loop logic.
             // requestAnimationFrame(gameLoop); // Keep requesting to potentially catch state changes
            return;
        }

        // --- Bird Physics ---
        birdVelocity += gravity;
        birdY += birdVelocity;

        // --- Pipe Logic ---
        pipeSpawnTimer++;
        if (pipeSpawnTimer > pipeSpawnInterval) {
            createPipePair();
            pipeSpawnTimer = 0;
        }

        movePipes();
        removeOffscreenPipes();

        // --- Collision Detection ---
        if (checkCollisions()) {
            gameOver();
            return; // Stop this frame processing
        }

        // --- Score ---
        updateScore();

        // --- Rendering ---
        render();

        // --- Loop ---
        gameLoopInterval = requestAnimationFrame(gameLoop);
    }

    function createPipePair() {
        const minHeight = 50; // Min height for top/bottom pipe parts
        const maxGapTop = gameHeight - pipeGap - minHeight; // Max top position for the gap start
        const gapTop = Math.random() * (maxGapTop - minHeight) + minHeight; // Random Y position for the top of the gap

        const pipePairElement = document.createElement('div');
        pipePairElement.classList.add('pipe-pair');
        pipePairElement.style.left = `${gameWidth}px`; // Start off-screen right

        const topPipe = document.createElement('div');
        topPipe.classList.add('pipe', 'pipe-top');
        topPipe.style.height = `${gapTop}px`; // Height of the top pipe section

        const bottomPipe = document.createElement('div');
        bottomPipe.classList.add('pipe', 'pipe-bottom');
        bottomPipe.style.height = `${gameHeight - gapTop - pipeGap}px`; // Height of the bottom pipe section

        pipePairElement.appendChild(topPipe); // Add top first for correct flex layout
        pipePairElement.appendChild(bottomPipe);

        gameContainer.appendChild(pipePairElement);

        pipes.push({
            element: pipePairElement,
            x: gameWidth,
            gapY: gapTop, // Store the top Y coordinate of the gap
            width: pipeWidth,
            gapHeight: pipeGap,
            scored: false // Flag to track if score was awarded for this pipe
        });
    }

    function movePipes() {
        pipes.forEach(pipe => {
            pipe.x -= pipeSpeed;
            pipe.element.style.left = `${pipe.x}px`;
        });
    }

    function removeOffscreenPipes() {
        pipes = pipes.filter(pipe => {
            if (pipe.x + pipe.width < 0) {
                pipe.element.remove(); // Remove element from DOM
                return false; // Remove from array
            }
            return true;
        });
    }

    function checkCollisions() {
        // Ground collision
        if (birdY + birdHeight > gameHeight) {
             birdY = gameHeight - birdHeight; // Don't fall through floor visually
             birdVelocity = 0;
             return true;
        }
        // Ceiling collision
        if (birdY < 0) {
            birdY = 0; // Prevent going above ceiling
            birdVelocity = 0; // Stop upward momentum if hitting ceiling
            // return true; // Optionally make hitting the ceiling game over
        }

        // Pipe collision
        const birdRect = {
             x: gameWidth * 0.2, // Bird's fixed horizontal position (approx)
             y: birdY,
             width: birdWidth,
             height: birdHeight
        };

        for (const pipe of pipes) {
            const topPipeRect = {
                x: pipe.x,
                y: 0,
                width: pipe.width,
                height: pipe.gapY
            };
            const bottomPipeRect = {
                x: pipe.x,
                y: pipe.gapY + pipe.gapHeight,
                width: pipe.width,
                height: gameHeight - (pipe.gapY + pipe.gapHeight)
            };

            if (rectsOverlap(birdRect, topPipeRect) || rectsOverlap(birdRect, bottomPipeRect)) {
                return true;
            }
        }

        return false;
    }

    function rectsOverlap(rect1, rect2) {
        return (
            rect1.x < rect2.x + rect2.width &&
            rect1.x + rect1.width > rect2.x &&
            rect1.y < rect2.y + rect2.height &&
            rect1.y + rect1.height > rect2.y
        );
    }

    function updateScore() {
         const birdCenterX = gameWidth * 0.2 + birdWidth / 2; // Bird's fixed horizontal position center
         pipes.forEach(pipe => {
             const pipeCenterX = pipe.x + pipe.width / 2;
              if (!pipe.scored && birdCenterX > pipeCenterX) {
                 score++;
                 scoreElement.textContent = score;
                 pipe.scored = true;
              }
         });
    }

    function render() {
        birdElement.style.top = `${birdY}px`;

        // Rotate bird based on velocity
        let rotation = Math.max(-25, Math.min(90, birdVelocity * 5)); // Clamp rotation between -25 and 90 degrees
        birdElement.style.transform = `rotate(${rotation}deg)`;
    }

    function gameOver() {
        gameState = 'gameover';
         if (gameLoopInterval) {
            cancelAnimationFrame(gameLoopInterval);
            gameLoopInterval = null;
        }
        finalScoreElement.textContent = score;
        gameOverMessage.classList.remove('hidden');
    }

    // --- Event Listeners ---
    document.addEventListener('keydown', (e) => {
        if (e.code === 'Space') {
            e.preventDefault(); // Prevent page scroll
            flap();
        }
    });

    gameContainer.addEventListener('mousedown', (e) => {
         e.preventDefault(); // Prevent text selection/dragging
         flap();
    });
     gameContainer.addEventListener('touchstart', (e) => {
         e.preventDefault(); // Prevent default touch actions like scrolling/zooming
         flap();
    });


    restartButton.addEventListener('click', (e) => {
         e.stopPropagation(); // Prevent click propagating to game container
        startGame();
    });

    // --- Initial Start ---
    startGame(); // Set up the initial screen

</script>

</body>
</html>