<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Storytelling Dice</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Simple Dice Roll Animation */
        @keyframes roll {
            0% { transform: rotate(0deg) scale(1); }
            20% { transform: rotate(180deg) scale(1.2); }
            40% { transform: rotate(360deg) scale(1); }
            60% { transform: rotate(540deg) scale(1.2); }
            80% { transform: rotate(720deg) scale(1); }
            100% { transform: rotate(720deg) scale(1); }
        }
        .dice-rolling {
            animation: roll 0.8s ease-in-out;
        }
        /* Fade in animation */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .fade-in {
            animation: fadeIn 0.5s ease-out forwards;
        }
        /* Basic scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        /* Hide number input spinners */
        input[type=number]::-webkit-inner-spin-button,
        input[type=number]::-webkit-outer-spin-button {
          -webkit-appearance: none;
          margin: 0;
        }
        input[type=number] {
          -moz-appearance: textfield; /* Firefox */
        }
    </style>
</head>
<body class="bg-gradient-to-br from-slate-900 to-slate-800 text-slate-200 font-sans antialiased">

    <div class="container mx-auto p-4 md:p-8 min-h-screen flex flex-col">

        <header class="text-center mb-8 md:mb-12">
            <h1 class="text-4xl md:text-5xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-purple-400 via-pink-500 to-red-500 mb-2">Dynamic Storytelling Dice</h1>
            <p class="text-lg text-slate-400">Craft branching narratives by rolling virtual dice.</p>
        </header>

        <main class="flex-grow grid grid-cols-1 lg:grid-cols-3 gap-8">

            <!-- Story Display Section -->
            <section class="lg:col-span-2 bg-slate-800/50 rounded-lg shadow-xl p-6 flex flex-col">
                <h2 class="text-2xl font-semibold mb-4 text-purple-300 border-b border-slate-700 pb-2">Your Story</h2>
                <div id="story-display" class="flex-grow space-y-4 overflow-y-auto max-h-[60vh] lg:max-h-full pr-2 text-slate-300 text-lg leading-relaxed">
                    <!-- Story segments will be added here -->
                    <p id="current-story-segment" class="fade-in">Welcome! Define your story nodes and dice, then roll to begin.</p>
                </div>
                <div id="story-end-message" class="mt-4 text-center text-xl font-semibold text-yellow-400 hidden">
                    The End.
                </div>
            </section>

            <!-- Controls and Dice Section -->
            <section class="bg-slate-800/50 rounded-lg shadow-xl p-6 flex flex-col space-y-6">
                <div>
                    <h2 class="text-2xl font-semibold mb-4 text-purple-300 border-b border-slate-700 pb-2">Dice Roller</h2>
                    <div id="dice-area" class="flex flex-col items-center space-y-4">
                        <div id="dice-container" class="w-24 h-24 md:w-32 md:h-32 bg-gradient-to-br from-indigo-500 to-purple-600 rounded-lg shadow-lg flex items-center justify-center text-center p-2 cursor-pointer transition-transform duration-100 hover:scale-105 active:scale-95">
                            <span id="dice-face" class="text-sm md:text-base font-bold text-white break-words">Click to Roll</span>
                        </div>
                        <button id="roll-button" class="w-full bg-pink-600 hover:bg-pink-700 text-white font-bold py-3 px-4 rounded-lg transition duration-150 ease-in-out shadow-md disabled:opacity-50 disabled:cursor-not-allowed">
                            Roll Dice
                        </button>
                        <p id="roll-outcome-display" class="text-center text-slate-400 h-6"></p>
                    </div>
                </div>

                <div>
                    <h2 class="text-2xl font-semibold mb-4 text-purple-300 border-b border-slate-700 pb-2">Story Controls</h2>
                    <div class="space-y-3">
                         <button id="restart-button" class="w-full bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 px-4 rounded-lg transition duration-150 ease-in-out shadow-md">
                            Restart Story
                        </button>
                        <button id="edit-story-button" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition duration-150 ease-in-out shadow-md">
                            Edit Story & Dice
                        </button>
                         <button id="save-story-button" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg transition duration-150 ease-in-out shadow-md">
                            Save Story
                        </button>
                         <button id="load-story-button" class="w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition duration-150 ease-in-out shadow-md">
                            Load Story
                        </button>
                         <input type="file" id="load-file-input" accept=".json" class="hidden">
                         <button id="share-story-button" class="w-full bg-teal-600 hover:bg-teal-700 text-white font-bold py-2 px-4 rounded-lg transition duration-150 ease-in-out shadow-md">
                            Share (Copy Data)
                        </button>
                    </div>
                </div>
            </section>

        </main>

        <!-- Footer -->
        <footer class="text-center mt-8 md:mt-12 text-slate-500 text-sm">
            <p>&copy; 2023 Dynamic Storytelling Dice. Created with HTML, Tailwind CSS, and JavaScript.</p>
        </footer>

    </div>

    <!-- Edit Story Modal -->
    <div id="edit-modal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4 hidden z-50">
        <div class="bg-slate-800 rounded-lg shadow-xl p-6 w-full max-w-4xl max-h-[90vh] flex flex-col">
            <div class="flex justify-between items-center mb-4 border-b border-slate-700 pb-3">
                <h3 class="text-2xl font-semibold text-purple-300">Edit Story & Dice</h3>
                <button id="close-modal-button" class="text-slate-400 hover:text-white text-2xl">&times;</button>
            </div>

            <div class="flex-grow overflow-y-auto pr-2 space-y-6">
                <!-- Dice Sets Editor -->
                <section>
                    <h4 class="text-xl font-semibold mb-3 text-purple-400">Dice Sets</h4>
                    <div id="dice-sets-editor" class="space-y-4">
                        <!-- Dice set inputs will be generated here -->
                    </div>
                    <button id="add-dice-set-button" class="mt-3 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded text-sm transition duration-150 ease-in-out shadow-md">+ Add Dice Set</button>
                </section>

                <!-- Story Nodes Editor -->
                <section>
                    <h4 class="text-xl font-semibold mb-3 text-purple-400">Story Nodes</h4>
                     <div class="mb-3">
                        <label for="start-node-select" class="block text-sm font-medium text-slate-300 mb-1">Start Node:</label>
                        <select id="start-node-select" class="w-full bg-slate-700 border border-slate-600 rounded px-3 py-2 text-white focus:outline-none focus:ring-2 focus:ring-purple-500">
                            <!-- Options will be populated dynamically -->
                        </select>
                    </div>
                    <div id="story-nodes-editor" class="space-y-4">
                        <!-- Story node inputs will be generated here -->
                    </div>
                    <button id="add-story-node-button" class="mt-3 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded text-sm transition duration-150 ease-in-out shadow-md">+ Add Story Node</button>
                </section>
            </div>

            <div class="mt-6 pt-4 border-t border-slate-700 flex justify-end space-x-3">
                <button id="cancel-edit-button" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded transition duration-150 ease-in-out shadow-md">Cancel</button>
                <button id="save-edit-button" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded transition duration-150 ease-in-out shadow-md">Save Changes</button>
            </div>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const storyDisplay = document.getElementById('story-display');
        const currentStorySegment = document.getElementById('current-story-segment');
        const storyEndMessage = document.getElementById('story-end-message');
        const diceContainer = document.getElementById('dice-container');
        const diceFace = document.getElementById('dice-face');
        const rollButton = document.getElementById('roll-button');
        const rollOutcomeDisplay = document.getElementById('roll-outcome-display');
        const restartButton = document.getElementById('restart-button');
        const editStoryButton = document.getElementById('edit-story-button');
        const saveStoryButton = document.getElementById('save-story-button');
        const loadStoryButton = document.getElementById('load-story-button');
        const loadFileInput = document.getElementById('load-file-input');
        const shareStoryButton = document.getElementById('share-story-button');
        const editModal = document.getElementById('edit-modal');
        const closeModalButton = document.getElementById('close-modal-button');
        const cancelEditButton = document.getElementById('cancel-edit-button');
        const saveEditButton = document.getElementById('save-edit-button');
        const diceSetsEditor = document.getElementById('dice-sets-editor');
        const addDiceSetButton = document.getElementById('add-dice-set-button');
        const storyNodesEditor = document.getElementById('story-nodes-editor');
        const addStoryNodeButton = document.getElementById('add-story-node-button');
        const startNodeSelect = document.getElementById('start-node-select');

        // --- Game State ---
        let storyData = {
            startNode: 'intro',
            nodes: {
                'intro': {
                    id: 'intro',
                    text: "You stand before a towering, ancient gate shrouded in mist. Moss clings to the weathered stone. Two paths diverge before it.",
                    diceSetId: 'directionDice',
                    outcomes: {
                        'Examine Gate': 'examineGate',
                        'Take Left Path': 'leftPath',
                        'Take Right Path': 'rightPath',
                        'Listen Closely': 'listen',
                        'Wait Patiently': 'wait',
                        'Shout Challenge': 'shout'
                    }
                },
                'examineGate': {
                    id: 'examineGate',
                    text: "The gate is sealed shut by magic and time. Strange symbols glow faintly upon its surface. You feel a cold draft.",
                    diceSetId: 'reactionDice',
                    outcomes: {
                        'Touch Symbols': 'touchSymbols',
                        'Step Back': 'stepBack',
                        'Search Area': 'searchArea',
                        'Push Gate': 'pushGate',
                        'Speak Keyword': 'speakKeyword',
                        'Ignore & Leave': 'leave'
                    }
                },
                 'leftPath': {
                    id: 'leftPath',
                    text: "The left path winds into a dark, whispering wood. Shadows dance between the trees.",
                    diceSetId: null, // End node example
                    outcomes: {}
                },
                 'rightPath': {
                    id: 'rightPath',
                    text: "The right path climbs a rocky slope towards distant peaks. The air grows thin.",
                    diceSetId: null, // End node example
                    outcomes: {}
                },
                'listen': {
                    id: 'listen',
                    text: "You hear faint chanting from beyond the gate and the scuttling of small creatures nearby.",
                    diceSetId: 'reactionDice',
                    outcomes: {
                        'Touch Symbols': 'touchSymbols',
                        'Step Back': 'stepBack',
                        'Search Area': 'searchArea',
                        'Push Gate': 'pushGate',
                        'Speak Keyword': 'speakKeyword',
                        'Ignore & Leave': 'leave'
                    }
                 },
                 'wait': {
                    id: 'wait',
                    text: "You wait. The mist thickens, and a sense of unease grows. Nothing happens immediately.",
                     diceSetId: 'directionDice',
                    outcomes: {
                        'Examine Gate': 'examineGate',
                        'Take Left Path': 'leftPath',
                        'Take Right Path': 'rightPath',
                        'Listen Closely': 'listen',
                        'Wait Patiently': 'wait', // Loop back possible
                        'Shout Challenge': 'shout'
                    }
                 },
                 'shout': {
                     id: 'shout',
                     text: "Your challenge echoes, but only silence answers. A lone raven watches you from a dead branch.",
                     diceSetId: 'reactionDice',
                     outcomes: {
                        'Touch Symbols': 'touchSymbols',
                        'Step Back': 'stepBack',
                        'Search Area': 'searchArea',
                        'Push Gate': 'pushGate',
                        'Speak Keyword': 'speakKeyword',
                        'Ignore & Leave': 'leave'
                    }
                 },
                 // Add more nodes based on outcomes...
                 'touchSymbols': { id: 'touchSymbols', text: "A shock runs up your arm! The symbols flare brightly, then fade. The gate remains sealed.", diceSetId: null, outcomes: {} },
                 'stepBack': { id: 'stepBack', text: "You cautiously step back, observing the gate from a distance. Nothing changes.", diceSetId: 'directionDice', outcomes: { /* ... link back or to new options ... */ } },
                 'searchArea': { id: 'searchArea', text: "Searching the ground reveals a discarded, rusty key. It doesn't fit the gate.", diceSetId: null, outcomes: {} },
                 'pushGate': { id: 'pushGate', text: "You push with all your might, but the massive gate doesn't budge.", diceSetId: null, outcomes: {} },
                 'speakKeyword': { id: 'speakKeyword', text: "You guess a keyword... 'Open!'... Nothing happens. Maybe it needs a specific phrase?", diceSetId: null, outcomes: {} },
                 'leave': { id: 'leave', text: "Deciding this isn't worth the trouble, you turn back the way you came.", diceSetId: null, outcomes: {} },
            },
            diceSets: {
                'directionDice': {
                    id: 'directionDice',
                    name: 'Direction Choice',
                    faces: [
                        'Examine Gate',
                        'Take Left Path',
                        'Take Right Path',
                        'Listen Closely',
                        'Wait Patiently',
                        'Shout Challenge'
                    ]
                },
                'reactionDice': {
                    id: 'reactionDice',
                    name: 'Reaction Choice',
                    faces: [
                        'Touch Symbols',
                        'Step Back',
                        'Search Area',
                        'Push Gate',
                        'Speak Keyword',
                        'Ignore & Leave'
                    ]
                }
            }
        };

        let currentState = {
            currentNodeId: null, // Will be set to storyData.startNode
            history: [], // Array of {nodeId, rolledOutcome}
            isRolling: false
        };

        let originalStoryData = JSON.parse(JSON.stringify(storyData)); // For cancelling edits

        // --- Functions ---

        function getRandomInt(max) {
            return Math.floor(Math.random() * max);
        }

        function getCurrentNode() {
            return storyData.nodes[currentState.currentNodeId];
        }

        function getCurrentDiceSet() {
            const node = getCurrentNode();
            if (!node || !node.diceSetId) return null;
            return storyData.diceSets[node.diceSetId];
        }

        function updateStoryDisplay(node, rolledOutcome = null) {
            const segmentElement = document.createElement('div');
            segmentElement.classList.add('mb-4', 'pb-4', 'border-b', 'border-slate-700/50', 'fade-in');

            if (currentState.history.length > 0) {
                 const outcomeElement = document.createElement('p');
                 outcomeElement.classList.add('text-sm', 'text-purple-400', 'italic', 'mb-1');
                 outcomeElement.textContent = `Rolled: "${rolledOutcome}"`;
                 segmentElement.appendChild(outcomeElement);
            }

            const textElement = document.createElement('p');
            textElement.textContent = node.text;
            segmentElement.appendChild(textElement);

            // Replace the placeholder or append new segment
            if (currentState.history.length === 0 && currentStorySegment.textContent === 'Welcome! Define your story nodes and dice, then roll to begin.') {
                 storyDisplay.replaceChild(segmentElement, currentStorySegment);
            } else {
                // Insert new segment at the top
                 storyDisplay.insertBefore(segmentElement, storyDisplay.firstChild);
            }

            // Scroll to top of story display
            storyDisplay.scrollTop = 0;
        }

        function updateDiceUI() {
            const diceSet = getCurrentDiceSet();
            rollOutcomeDisplay.textContent = ''; // Clear previous outcome

            if (diceSet && diceSet.faces.length > 0) {
                diceFace.textContent = `Roll: ${diceSet.name || 'Unnamed Dice'}`;
                rollButton.disabled = false;
                diceContainer.classList.remove('opacity-50', 'cursor-not-allowed');
                storyEndMessage.classList.add('hidden');
            } else {
                diceFace.textContent = 'The End';
                rollButton.disabled = true;
                diceContainer.classList.add('opacity-50', 'cursor-not-allowed');
                storyEndMessage.classList.remove('hidden');
            }
        }

        function performRoll() {
            if (currentState.isRolling || rollButton.disabled) return;

            const diceSet = getCurrentDiceSet();
            if (!diceSet || diceSet.faces.length === 0) return;

            currentState.isRolling = true;
            rollButton.disabled = true;
            diceContainer.classList.add('dice-rolling');
            rollOutcomeDisplay.textContent = 'Rolling...';

            let rollInterval = setInterval(() => {
                const randomFaceIndex = getRandomInt(diceSet.faces.length);
                diceFace.textContent = diceSet.faces[randomFaceIndex];
            }, 100);

            setTimeout(() => {
                clearInterval(rollInterval);
                diceContainer.classList.remove('dice-rolling');

                const finalFaceIndex = getRandomInt(diceSet.faces.length);
                const rolledOutcome = diceSet.faces[finalFaceIndex];
                diceFace.textContent = rolledOutcome;
                rollOutcomeDisplay.textContent = `Rolled: ${rolledOutcome}`;

                const currentNode = getCurrentNode();
                const nextNodeId = currentNode.outcomes[rolledOutcome];

                currentState.history.push({ nodeId: currentState.currentNodeId, rolledOutcome: rolledOutcome });

                if (nextNodeId && storyData.nodes[nextNodeId]) {
                    currentState.currentNodeId = nextNodeId;
                    const nextNode = storyData.nodes[nextNodeId];
                    updateStoryDisplay(nextNode, rolledOutcome);
                    updateDiceUI();
                } else {
                    // Handle dead end or undefined next node
                    const endNode = { text: `(No defined path for "${rolledOutcome}") The story pauses here.` };
                    updateStoryDisplay(endNode, rolledOutcome);
                    diceFace.textContent = 'The End';
                    rollButton.disabled = true;
                    diceContainer.classList.add('opacity-50', 'cursor-not-allowed');
                     storyEndMessage.classList.remove('hidden');
                     storyEndMessage.textContent = `The story ended unexpectedly after rolling "${rolledOutcome}". You could edit the story to add a path!`;
                }

                currentState.isRolling = false;
                // Re-enable button only if not at the end
                if (getCurrentDiceSet()) {
                     rollButton.disabled = false;
                }

            }, 800); // Match animation duration
        }

        function startStory(storyToLoad = storyData) {
            storyData = JSON.parse(JSON.stringify(storyToLoad)); // Deep copy to avoid modifying original during play
            currentState.currentNodeId = storyData.startNode;
            currentState.history = [];
            storyDisplay.innerHTML = ''; // Clear previous story segments
            storyDisplay.appendChild(currentStorySegment); // Add back the placeholder initially
            currentStorySegment.textContent = 'Starting new story...'; // Temporary message
            storyEndMessage.classList.add('hidden');


            if (storyData.nodes[currentState.currentNodeId]) {
                const startNode = storyData.nodes[currentState.currentNodeId];
                updateStoryDisplay(startNode);
                updateDiceUI();
            } else {
                currentStorySegment.textContent = 'Error: Start node not found!';
                rollButton.disabled = true;
                diceContainer.classList.add('opacity-50', 'cursor-not-allowed');
            }
        }

        function saveStory() {
            try {
                const storyJson = JSON.stringify(storyData, null, 2);
                localStorage.setItem('dynamicStoryData', storyJson);
                alert('Story saved successfully to browser storage!');
            } catch (error) {
                console.error("Error saving story:", error);
                alert('Error saving story. Check console for details.');
            }
        }

        function loadStory() {
            const savedStoryJson = localStorage.getItem('dynamicStoryData');
            if (savedStoryJson) {
                try {
                    const loadedData = JSON.parse(savedStoryJson);
                    // Basic validation
                    if (loadedData.startNode && loadedData.nodes && loadedData.diceSets) {
                        storyData = loadedData;
                        originalStoryData = JSON.parse(JSON.stringify(storyData)); // Update backup
                        startStory(storyData);
                        alert('Story loaded successfully from browser storage!');
                    } else {
                        alert('Loaded data is not a valid story structure.');
                    }
                } catch (error) {
                    console.error("Error loading story:", error);
                    alert('Error loading story from browser storage. It might be corrupted.');
                }
            } else {
                alert('No saved story found in browser storage.');
            }
        }

        function triggerLoadFromFile() {
            loadFileInput.click();
        }

        function loadStoryFromFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const loadedData = JSON.parse(e.target.result);
                     // Basic validation
                    if (loadedData.startNode && loadedData.nodes && loadedData.diceSets) {
                        storyData = loadedData;
                        originalStoryData = JSON.parse(JSON.stringify(storyData)); // Update backup
                        startStory(storyData);
                        alert(`Story "${file.name}" loaded successfully!`);
                    } else {
                        alert('Loaded file is not a valid story structure.');
                    }
                } catch (error) {
                    console.error("Error loading story from file:", error);
                    alert(`Error loading story from file "${file.name}". Check console for details.`);
                } finally {
                    // Reset file input to allow loading the same file again
                    loadFileInput.value = null;
                }
            };
            reader.onerror = function() {
                 alert(`Error reading file "${file.name}".`);
                 loadFileInput.value = null;
            };
            reader.readAsText(file);
        }


        function shareStory() {
             try {
                const storyJson = JSON.stringify(storyData, null, 2);
                navigator.clipboard.writeText(storyJson)
                    .then(() => {
                        alert('Story data copied to clipboard! You can paste it into a text file or message to share.');
                    })
                    .catch(err => {
                        console.error('Failed to copy story data: ', err);
                        alert('Failed to copy story data. Check console for details. You might need to grant clipboard permissions.');
                    });
            } catch (error) {
                console.error("Error preparing story data for sharing:", error);
                alert('Error preparing story data for sharing.');
            }
        }

        // --- Modal & Editing Functions ---

        function openEditModal() {
            originalStoryData = JSON.parse(JSON.stringify(storyData)); // Backup current state
            populateEditModal();
            editModal.classList.remove('hidden');
        }

        function closeEditModal() {
            editModal.classList.add('hidden');
            // Optionally restore original data if cancelled explicitly
        }

        function cancelEdits() {
             storyData = JSON.parse(JSON.stringify(originalStoryData)); // Restore backup
             closeEditModal();
             // No need to restart story, as changes were discarded
        }

        function saveEdits() {
            // 1. Read data from the modal inputs and update the main storyData object
            const updatedData = readDataFromModal();

             // Basic validation before saving
             if (!updatedData.startNode || Object.keys(updatedData.nodes).length === 0) {
                 alert("Cannot save: Story must have a start node and at least one node.");
                 return;
             }
             if (!updatedData.nodes[updatedData.startNode]) {
                 alert(`Cannot save: Selected start node "${updatedData.startNode}" does not exist.`);
                 return;
             }
             // Add more validation as needed (e.g., check if dice sets exist, outcomes point to valid nodes)


            storyData = updatedData; // Apply changes
            originalStoryData = JSON.parse(JSON.stringify(storyData)); // Update backup

            // 2. Close the modal
            closeEditModal();

            // 3. Restart the story with the updated data
            startStory(storyData);
            alert("Story updated successfully!");
        }

        function readDataFromModal() {
            const updatedStoryData = {
                startNode: startNodeSelect.value,
                nodes: {},
                diceSets: {}
            };

            // Read Dice Sets
            const diceSetDivs = diceSetsEditor.querySelectorAll('.dice-set-editor');
            diceSetDivs.forEach(div => {
                const idInput = div.querySelector('input[data-dice-prop="id"]');
                const nameInput = div.querySelector('input[data-dice-prop="name"]');
                const facesContainer = div.querySelector('.dice-faces-container');
                const faceInputs = facesContainer.querySelectorAll('input');

                if (idInput && idInput.value.trim()) {
                    const id = idInput.value.trim();
                    updatedStoryData.diceSets[id] = {
                        id: id,
                        name: nameInput ? nameInput.value.trim() : id,
                        faces: Array.from(faceInputs).map(input => input.value.trim()).filter(face => face) // Filter out empty faces
                    };
                }
            });

             // Read Story Nodes
             const nodeDivs = storyNodesEditor.querySelectorAll('.story-node-editor');
             nodeDivs.forEach(div => {
                 const idInput = div.querySelector('input[data-node-prop="id"]');
                 const textInput = div.querySelector('textarea[data-node-prop="text"]');
                 const diceSelect = div.querySelector('select[data-node-prop="diceSetId"]');
                 const outcomesContainer = div.querySelector('.node-outcomes-container');
                 const outcomeDivs = outcomesContainer.querySelectorAll('.node-outcome-editor');

                 if (idInput && idInput.value.trim()) {
                     const id = idInput.value.trim();
                     const outcomes = {};
                     outcomeDivs.forEach(outcomeDiv => {
                         const faceInput = outcomeDiv.querySelector('input[data-outcome-prop="face"]');
                         const nextNodeSelect = outcomeDiv.querySelector('select[data-outcome-prop="nextNodeId"]');
                         if (faceInput && faceInput.value.trim() && nextNodeSelect) {
                             outcomes[faceInput.value.trim()] = nextNodeSelect.value || null; // Use null if no node selected
                         }
                     });

                     updatedStoryData.nodes[id] = {
                         id: id,
                         text: textInput ? textInput.value.trim() : '',
                         diceSetId: diceSelect ? (diceSelect.value || null) : null, // Use null if no dice set selected
                         outcomes: outcomes
                     };
                 }
             });

            return updatedStoryData;
        }


        function populateEditModal() {
            // Clear existing editors
            diceSetsEditor.innerHTML = '';
            storyNodesEditor.innerHTML = '';
            startNodeSelect.innerHTML = ''; // Clear start node options

            // Populate Dice Sets
            Object.values(storyData.diceSets).forEach(diceSet => {
                addDiceSetEditor(diceSet);
            });

            // Populate Story Nodes
            const nodeIds = Object.keys(storyData.nodes);
            const diceSetIds = Object.keys(storyData.diceSets);

            // Populate Start Node Select FIRST
             nodeIds.forEach(nodeId => {
                const option = document.createElement('option');
                option.value = nodeId;
                option.textContent = nodeId;
                if (nodeId === storyData.startNode) {
                    option.selected = true;
                }
                startNodeSelect.appendChild(option);
            });


            Object.values(storyData.nodes).forEach(node => {
                addStoryNodeEditor(node, nodeIds, diceSetIds);
            });

            // Ensure add buttons work after populating
             setupAddButtons();
        }

        function createInput(type, placeholder, value, dataAttribute, dataValue) {
            const input = document.createElement(type === 'textarea' ? 'textarea' : 'input');
            if (type !== 'textarea') input.type = type;
            input.className = 'w-full bg-slate-700 border border-slate-600 rounded px-3 py-2 text-white focus:outline-none focus:ring-2 focus:ring-purple-500 text-sm';
            input.placeholder = placeholder;
            input.value = value || '';
            if (type === 'textarea') input.rows = 3;
            if (dataAttribute) input.dataset[dataAttribute] = dataValue;
            return input;
        }

         function createSelect(options, selectedValue, dataAttribute, dataValue, includeNone = false) {
            const select = document.createElement('select');
            select.className = 'w-full bg-slate-700 border border-slate-600 rounded px-3 py-2 text-white focus:outline-none focus:ring-2 focus:ring-purple-500 text-sm';
            if (dataAttribute) select.dataset[dataAttribute] = dataValue;

            if (includeNone) {
                const noneOption = document.createElement('option');
                noneOption.value = '';
                noneOption.textContent = '-- None --';
                select.appendChild(noneOption);
            }

            options.forEach(optValue => {
                const option = document.createElement('option');
                option.value = optValue;
                option.textContent = optValue;
                if (optValue === selectedValue) {
                    option.selected = true;
                }
                select.appendChild(option);
            });
             // Ensure the selected value is actually set if it exists
             if (selectedValue) select.value = selectedValue;
             else if (includeNone) select.value = ''; // Default to None if selectedValue is null/undefined

            return select;
        }

        function createDeleteButton(onClick) {
             const button = document.createElement('button');
             button.innerHTML = '&times;'; // Use innerHTML for the times symbol
             button.className = 'ml-2 text-red-500 hover:text-red-400 font-bold text-lg px-2';
             button.title = 'Delete';
             button.type = 'button'; // Prevent form submission if wrapped in form
             button.onclick = onClick;
             return button;
        }


        function addDiceSetEditor(diceSet = { id: '', name: '', faces: [''] }) {
            const div = document.createElement('div');
            div.className = 'dice-set-editor p-4 border border-slate-700 rounded-lg space-y-3 bg-slate-900/30';

            const idInput = createInput('text', 'Dice Set ID (e.g., movementDice)', diceSet.id, 'diceProp', 'id');
            const nameInput = createInput('text', 'Dice Set Name (e.g., Movement Dice)', diceSet.name, 'diceProp', 'name');

            const facesContainer = document.createElement('div');
            facesContainer.className = 'dice-faces-container space-y-2 pl-4 border-l-2 border-slate-600';
            facesContainer.innerHTML = '<label class="block text-sm font-medium text-slate-300 mb-1">Faces:</label>';

            diceSet.faces.forEach((face, index) => {
                addDiceFaceInput(facesContainer, face);
            });
             // Add an empty one if the set is empty or for adding more
             if (diceSet.faces.length === 0) {
                 addDiceFaceInput(facesContainer, '');
             }


            const addFaceButton = document.createElement('button');
            addFaceButton.textContent = '+ Add Face';
            addFaceButton.className = 'text-sm bg-green-700 hover:bg-green-800 text-white font-semibold py-1 px-2 rounded transition duration-150 ease-in-out shadow';
            addFaceButton.type = 'button';
            addFaceButton.onclick = () => addDiceFaceInput(facesContainer, '');

             const deleteSetButton = createDeleteButton(() => div.remove());

             const headerDiv = document.createElement('div');
             headerDiv.className = 'flex justify-between items-center';
             headerDiv.innerHTML = '<label class="block text-sm font-medium text-slate-300">Dice Set ID:</label>';
             headerDiv.appendChild(deleteSetButton);


            div.appendChild(headerDiv);
            div.appendChild(idInput);
            div.appendChild(document.createElement('label'). L = '<label class="block text-sm font-medium text-slate-300">Dice Set Name:</label>');
            div.appendChild(nameInput);
            div.appendChild(facesContainer);
            div.appendChild(addFaceButton);

            diceSetsEditor.appendChild(div);
        }

        function addDiceFaceInput(container, faceValue) {
            const faceDiv = document.createElement('div');
            faceDiv.className = 'flex items-center';
            const faceInput = createInput('text', 'Face Text', faceValue);
            faceInput.classList.add('flex-grow');
            const removeFaceButton = createDeleteButton(() => faceDiv.remove());
            removeFaceButton.classList.add('text-base'); // Slightly smaller delete button

            faceDiv.appendChild(faceInput);
            faceDiv.appendChild(removeFaceButton);
            container.appendChild(faceDiv);
        }


        function addStoryNodeEditor(node = { id: '', text: '', diceSetId: null, outcomes: {} }, allNodeIds, allDiceSetIds) {
            const div = document.createElement('div');
            div.className = 'story-node-editor p-4 border border-slate-700 rounded-lg space-y-3 bg-slate-900/30';

            const idInput = createInput('text', 'Node ID (e.g., caveEntrance)', node.id, 'nodeProp', 'id');
            const textInput = createInput('textarea', 'Story text for this node...', node.text, 'nodeProp', 'text');
            const diceSelect = createSelect(allDiceSetIds, node.diceSetId, 'nodeProp', 'diceSetId', true); // Include '-- None --' option

            const outcomesContainer = document.createElement('div');
            outcomesContainer.className = 'node-outcomes-container space-y-2 pl-4 border-l-2 border-slate-600';
            outcomesContainer.innerHTML = '<label class="block text-sm font-medium text-slate-300 mb-1">Outcomes (Based on Dice Roll):</label>';

            Object.entries(node.outcomes).forEach(([face, nextNodeId]) => {
                addNodeOutcomeEditor(outcomesContainer, allNodeIds, face, nextNodeId);
            });
             // Add an empty one for adding new outcomes
             addNodeOutcomeEditor(outcomesContainer, allNodeIds, '', null);

            const addOutcomeButton = document.createElement('button');
            addOutcomeButton.textContent = '+ Add Outcome';
            addOutcomeButton.className = 'text-sm bg-green-700 hover:bg-green-800 text-white font-semibold py-1 px-2 rounded transition duration-150 ease-in-out shadow';
            addOutcomeButton.type = 'button';
            addOutcomeButton.onclick = () => addNodeOutcomeEditor(outcomesContainer, getNodeIdsFromEditor(), '', null); // Get current node IDs from editor state

             const deleteNodeButton = createDeleteButton(() => {
                 div.remove();
                 updateAllNodeSelects(); // Update dropdowns in other nodes
                 updateStartNodeSelect(); // Update the main start node dropdown
             });

             const headerDiv = document.createElement('div');
             headerDiv.className = 'flex justify-between items-center';
             headerDiv.innerHTML = '<label class="block text-sm font-medium text-slate-300">Node ID:</label>';
             headerDiv.appendChild(deleteNodeButton);

            div.appendChild(headerDiv);
            div.appendChild(idInput);
            div.appendChild(document.createElement('label'). L = '<label class="block text-sm font-medium text-slate-300 mt-2">Story Text:</label>');
            div.appendChild(textInput);
            div.appendChild(document.createElement('label'). L = '<label class="block text-sm font-medium text-slate-300 mt-2">Dice Set for Next Roll:</label>');
            div.appendChild(diceSelect);
            div.appendChild(outcomesContainer);
            div.appendChild(addOutcomeButton);

            storyNodesEditor.appendChild(div);

             // Update other dropdowns when a node ID changes
             idInput.addEventListener('change', () => {
                 updateAllNodeSelects();
                 updateStartNodeSelect();
             });
        }

         function addNodeOutcomeEditor(container, allNodeIds, faceValue, nextNodeIdValue) {
            const outcomeDiv = document.createElement('div');
            outcomeDiv.className = 'node-outcome-editor flex items-center space-x-2';

            const faceInput = createInput('text', 'Dice Face Text', faceValue, 'outcomeProp', 'face');
            faceInput.classList.add('w-1/3');
            const arrowSpan = document.createElement('span');
            arrowSpan.textContent = '->';
            arrowSpan.className = 'text-slate-400';
            const nextNodeSelect = createSelect(allNodeIds, nextNodeIdValue, 'outcomeProp', 'nextNodeId', true); // Allow '-- None --' for end points
            nextNodeSelect.classList.add('flex-grow');
            const removeOutcomeButton = createDeleteButton(() => outcomeDiv.remove());
            removeOutcomeButton.classList.add('text-base');

            outcomeDiv.appendChild(faceInput);
            outcomeDiv.appendChild(arrowSpan);
            outcomeDiv.appendChild(nextNodeSelect);
            outcomeDiv.appendChild(removeOutcomeButton);
            container.appendChild(outcomeDiv);
        }

        // Helper to get current node IDs directly from the editor inputs
        function getNodeIdsFromEditor() {
            const idInputs = storyNodesEditor.querySelectorAll('input[data-node-prop="id"]');
            return Array.from(idInputs).map(input => input.value.trim()).filter(id => id);
        }

        // Helper to update all node selection dropdowns in the editor
        function updateAllNodeSelects() {
            const currentNodeIds = getNodeIdsFromEditor();
            const allSelects = storyNodesEditor.querySelectorAll('select[data-outcome-prop="nextNodeId"]');
            allSelects.forEach(select => {
                const currentValue = select.value;
                select.innerHTML = ''; // Clear existing options

                // Add '-- None --' option
                const noneOption = document.createElement('option');
                noneOption.value = '';
                noneOption.textContent = '-- None --';
                select.appendChild(noneOption);

                // Add current node IDs
                currentNodeIds.forEach(nodeId => {
                    const option = document.createElement('option');
                    option.value = nodeId;
                    option.textContent = nodeId;
                    select.appendChild(option);
                });

                // Try to restore previous selection
                if (currentNodeIds.includes(currentValue)) {
                    select.value = currentValue;
                } else {
                    select.value = ''; // Default to '-- None --' if previous ID deleted
                }
            });
        }

         // Helper to update the main start node select dropdown
         function updateStartNodeSelect() {
             const currentNodeIds = getNodeIdsFromEditor();
             const currentValue = startNodeSelect.value;
             startNodeSelect.innerHTML = ''; // Clear existing

             if (currentNodeIds.length === 0) {
                 const option = document.createElement('option');
                 option.value = '';
                 option.textContent = 'No nodes defined';
                 startNodeSelect.appendChild(option);
                 startNodeSelect.disabled = true;
             } else {
                 startNodeSelect.disabled = false;
                 currentNodeIds.forEach(nodeId => {
                     const option = document.createElement('option');
                     option.value = nodeId;
                     option.textContent = nodeId;
                     startNodeSelect.appendChild(option);
                 });
                 // Try to restore selection
                 if (currentNodeIds.includes(currentValue)) {
                     startNodeSelect.value = currentValue;
                 } else if (currentNodeIds.length > 0) {
                     startNodeSelect.value = currentNodeIds[0]; // Default to first if previous deleted
                 }
             }
         }

         // Helper to update dice set dropdowns in the editor
         function updateAllDiceSelects() {
             const currentDiceSetIds = Object.keys(readDataFromModal().diceSets); // Read current dice IDs
             const allSelects = storyNodesEditor.querySelectorAll('select[data-node-prop="diceSetId"]');
             allSelects.forEach(select => {
                 const currentValue = select.value;
                 select.innerHTML = ''; // Clear

                 // Add '-- None --'
                 const noneOption = document.createElement('option');
                 noneOption.value = '';
                 noneOption.textContent = '-- None --';
                 select.appendChild(noneOption);

                 // Add current dice set IDs
                 currentDiceSetIds.forEach(diceId => {
                     const option = document.createElement('option');
                     option.value = diceId;
                     option.textContent = storyData.diceSets[diceId]?.name || diceId; // Use name if available
                     select.appendChild(option);
                 });

                 // Restore selection
                 if (currentDiceSetIds.includes(currentValue)) {
                     select.value = currentValue;
                 } else {
                     select.value = '';
                 }
             });
         }

         function setupAddButtons() {
             // Remove potential old listeners before adding new ones
             const newAddDiceSetButton = addDiceSetButton.cloneNode(true);
             addDiceSetButton.parentNode.replaceChild(newAddDiceSetButton, addDiceSetButton);
             newAddDiceSetButton.addEventListener('click', () => addDiceSetEditor());

             const newAddStoryNodeButton = addStoryNodeButton.cloneNode(true);
             addStoryNodeButton.parentNode.replaceChild(newAddStoryNodeButton, addStoryNodeButton);
             newAddStoryNodeButton.addEventListener('click', () => {
                 addStoryNodeEditor(undefined, getNodeIdsFromEditor(), Object.keys(readDataFromModal().diceSets));
                 updateAllNodeSelects(); // Ensure new node is available in dropdowns
                 updateStartNodeSelect();
             });
         }


        // --- Event Listeners ---
        rollButton.addEventListener('click', performRoll);
        diceContainer.addEventListener('click', performRoll); // Allow clicking the dice itself
        restartButton.addEventListener('click', () => startStory(storyData)); // Restart with current data structure
        editStoryButton.addEventListener('click', openEditModal);
        closeModalButton.addEventListener('click', closeEditModal); // Simple close, doesn't restore data
        cancelEditButton.addEventListener('click', cancelEdits); // Explicit cancel restores data
        saveEditButton.addEventListener('click', saveEdits);
        saveStoryButton.addEventListener('click', saveStory);
        loadStoryButton.addEventListener('click', triggerLoadFromFile); // Changed to load from file
        loadFileInput.addEventListener('change', loadStoryFromFile);
        shareStoryButton.addEventListener('click', shareStory);

        // Initial setup
        document.addEventListener('DOMContentLoaded', () => {
             loadStory(); // Try loading from local storage first
             if (!currentState.currentNodeId) { // If nothing loaded, start with default
                 startStory(storyData);
             }
             setupAddButtons(); // Initial setup for add buttons in modal
        });

    </script>

</body>
</html>