<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visual Regex Tester</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Minor style for preserving whitespace and line breaks in output */
        #outputArea {
            white-space: pre-wrap;       /* CSS 3 */
            white-space: -moz-pre-wrap;  /* Mozilla, since 1999 */
            white-space: -pre-wrap;      /* Opera 4-6 */
            white-space: -o-pre-wrap;    /* Opera 7 */
            word-wrap: break-word;       /* Internet Explorer 5.5+ */
        }
        /* Simple scrollbar styling (optional, webkit only) */
        textarea::-webkit-scrollbar {
            width: 8px;
        }
        textarea::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        textarea::-webkit-scrollbar-thumb {
            background: #a0aec0; /* gray-500 */
            border-radius: 10px;
        }
        textarea::-webkit-scrollbar-thumb:hover {
            background: #718096; /* gray-600 */
        }
         #outputArea::-webkit-scrollbar {
            width: 8px;
        }
        #outputArea::-webkit-scrollbar-track {
            background: #f7fafc; /* gray-100 */
             border-radius: 10px;
        }
        #outputArea::-webkit-scrollbar-thumb {
            background: #cbd5e0; /* gray-400 */
             border-radius: 10px;
        }
        #outputArea::-webkit-scrollbar-thumb:hover {
            background: #a0aec0; /* gray-500 */
        }
    </style>
</head>
<body class="bg-gray-100 font-sans leading-normal tracking-normal">

    <div class="container mx-auto p-4 lg:p-8">

        <header class="mb-8 text-center">
            <h1 class="text-3xl md:text-4xl font-bold text-gray-800">Visual Regex Tester</h1>
            <p class="text-gray-600 mt-2">Test your regular expressions live.</p>
        </header>

        <main class="bg-white shadow-lg rounded-lg p-6 md:p-8">

            <div class="grid grid-cols-1 md:grid-cols-2 gap-6 md:gap-8">

                <!-- Input Section -->
                <section class="space-y-6">
                    <div>
                        <label for="regexInput" class="block text-sm font-medium text-gray-700 mb-1">Regular Expression</label>
                        <input type="text" id="regexInput" name="regexInput"
                               class="block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm placeholder-gray-400 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm font-mono"
                               placeholder="/pattern/flags (e.g., /hello/gi)"
                               oninput="updateOutput()">
                        <div id="errorDisplay" class="mt-1 text-xs text-red-600 font-medium h-4"></div>
                    </div>

                    <div>
                        <label for="testStringInput" class="block text-sm font-medium text-gray-700 mb-1">Test String</label>
                        <textarea id="testStringInput" name="testStringInput" rows="15"
                                  class="block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm placeholder-gray-400 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm font-mono resize-y"
                                  placeholder="Enter the text you want to test your regex against..."
                                  oninput="updateOutput()">The quick brown fox jumps over the lazy dog. 12345. Repeat: the quick brown fox.</textarea>
                    </div>
                </section>

                <!-- Output Section -->
                <section>
                    <label for="outputArea" class="block text-sm font-medium text-gray-700 mb-1">Live Output / Matches</label>
                    <div class="relative border border-gray-200 rounded-md bg-gray-50 h-[calc(18rem+4px)] md:h-full">
                        <div id="matchInfo" class="absolute top-2 right-3 text-xs text-gray-500 bg-gray-100 px-2 py-0.5 rounded">Enter a regex</div>
                        <pre id="outputArea" class="p-3 text-sm font-mono text-gray-800 h-full overflow-auto"></pre>
                    </div>
                </section>

            </div>

        </main>

        <footer class="mt-8 text-center text-gray-500 text-sm">
            <p>&copy; 2023 Visual Regex Tester. Built with Tailwind CSS.</p>
        </footer>

    </div>

    <script>
        function escapeHTML(str) {
            // Basic escaping to prevent HTML injection from test string when highlighting
            return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
        }

        function updateOutput() {
            const regexInput = document.getElementById('regexInput');
            const testStringInput = document.getElementById('testStringInput');
            const outputArea = document.getElementById('outputArea');
            const errorDisplay = document.getElementById('errorDisplay');
            const matchInfo = document.getElementById('matchInfo');

            const regexWithValue = regexInput.value; // Don't trim here, spaces might be intentional
            const testString = testStringInput.value;

            // Clear previous state
            errorDisplay.textContent = '';
            matchInfo.textContent = '';
            // Escape the *entire* test string first before doing any regex processing
            const escapedTestString = escapeHTML(testString);
            outputArea.innerHTML = escapedTestString; // Display escaped plain text initially

            if (!regexWithValue) {
                matchInfo.textContent = 'Enter a regex';
                return;
            }
             if (!testString) {
                matchInfo.textContent = 'Enter text to test';
                return;
            }


            let regex;
            let pattern = regexWithValue;
            let flags = '';
            let isValidFormat = false;

            // Basic parsing for /pattern/flags format
            if (regexWithValue.length > 1 && regexWithValue.startsWith('/') && regexWithValue.includes('/')) {
                const lastSlashIndex = regexWithValue.lastIndexOf('/');
                if (lastSlashIndex > 0) {
                    pattern = regexWithValue.substring(1, lastSlashIndex);
                    flags = regexWithValue.substring(lastSlashIndex + 1);
                    isValidFormat = true; // Indicates it matched the /pattern/flags structure
                }
            }

             // If not in /pattern/flags format, treat the whole input as the pattern with no flags
            if (!isValidFormat) {
                 pattern = regexWithValue;
                 flags = '';
            }

            // Always add 'g' flag internally for highlighting all matches, unless it's already there
            const effectiveFlags = flags.includes('g') ? flags : flags + 'g';

            try {
                // Use the parsed pattern and effective flags
                regex = new RegExp(pattern, effectiveFlags);

                let highlightedHTML = '';
                let lastIndex = 0;
                let match;
                let matchCount = 0;

                // Use exec loop on the *escaped* string for robust highlighting
                while ((match = regex.exec(escapedTestString)) !== null) {
                    // Append text before the match
                    highlightedHTML += escapedTestString.substring(lastIndex, match.index);
                    // Append the highlighted match
                    // Use a neutral background and slight bolding for matches
                    highlightedHTML += `<span class="bg-yellow-200 text-yellow-900 px-0.5 rounded font-medium">${match[0]}</span>`;
                    lastIndex = regex.lastIndex;
                    matchCount++;

                    // Prevent infinite loops with zero-width matches (like /^/gm)
                    if (match.index === regex.lastIndex) {
                         // If the regex matched an empty string, advance manually
                         if (match[0].length === 0) {
                            regex.lastIndex++;
                         } else {
                            // This case should technically not happen with standard regex behavior if match[0] is not empty
                            // but adding a safeguard.
                            break;
                         }
                    }
                     // Safety break for potential browser/regex edge cases with zero-width matches in loops
                    if (lastIndex >= escapedTestString.length && match[0].length === 0) {
                        break;
                    }
                }

                // Append the rest of the string after the last match
                highlightedHTML += escapedTestString.substring(lastIndex);

                // Update the output area with the highlighted HTML
                outputArea.innerHTML = highlightedHTML || escapedTestString; // Show original escaped string if no matches found but regex was valid

                // Update match info
                matchInfo.textContent = `${matchCount} match${matchCount !== 1 ? 'es' : ''} found`;

            } catch (e) {
                // Display specific regex error
                errorDisplay.textContent = `Invalid Regex: ${e.message}`;
                // Keep the plain (escaped) text in the output area on error
                outputArea.innerHTML = escapedTestString;
                matchInfo.textContent = 'Error';
            }
        }

        // Initial call to render placeholder text correctly on load
        document.addEventListener('DOMContentLoaded', updateOutput);
    </script>

</body>
</html>