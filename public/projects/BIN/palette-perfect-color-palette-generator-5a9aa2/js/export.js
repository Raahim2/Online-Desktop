const ExportUtils = {
    _downloadFile: function(filename, content, mimeType) {
        const blob = new Blob([content], { type: mimeType });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    },

    exportAsCSS: function(palette, paletteName = 'my-palette') {
        if (!Array.isArray(palette) || palette.length === 0) {
            console.error("Cannot export empty or invalid palette as CSS.");
            return;
        }
        const sanitizedPaletteName = paletteName.toLowerCase().replace(/[^a-z0-9_]+/g, '-');
        const cssVars = palette.map((colorObj, index) => {
            const hex = colorObj.hex || colorObj; // Handle array of strings or array of {hex: ''}
            return `  --${sanitizedPaletteName}-color-${index + 1}: ${hex.toUpperCase()};`;
        }).join('\n');
        const cssContent = `:root {\n${cssVars}\n}`;
        this._downloadFile(`${sanitizedPaletteName}-palette.css`, cssContent, 'text/css;charset=utf-8;');
    },

    exportAsJSON: function(palette, paletteName = 'my-palette') {
        if (!Array.isArray(palette) || palette.length === 0) {
            console.error("Cannot export empty or invalid palette as JSON.");
            return;
        }
        const colorsArray = palette.map(colorObj => (colorObj.hex || colorObj).toUpperCase());
        const jsonContent = JSON.stringify({
            name: paletteName,
            colors: colorsArray,
            generatedAt: new Date().toISOString()
        }, null, 2);
        const sanitizedPaletteName = paletteName.toLowerCase().replace(/[^a-z0-9_]+/g, '-');
        this._downloadFile(`${sanitizedPaletteName}-palette.json`, jsonContent, 'application/json;charset=utf-8;');
    },

    exportAsSVG: function(palette, paletteName = 'my-palette') {
        if (!Array.isArray(palette) || palette.length === 0) {
            console.error("Cannot export empty or invalid palette as SVG.");
            return;
        }
        const rectWidth = 100;
        const rectHeight = 400;
        const totalWidth = palette.length * rectWidth;

        const svgRects = palette.map((colorObj, index) => {
            const hex = colorObj.hex || colorObj; // Handle array of strings or array of {hex: ''}
            return `  <rect x="${index * rectWidth}" y="0" width="${rectWidth}" height="${rectHeight}" fill="${hex.toUpperCase()}" />`;
        }).join('\n');

        const svgContent = `<svg width="${totalWidth}" height="${rectHeight}" viewBox="0 0 ${totalWidth} ${rectHeight}" xmlns="http://www.w3.org/2000/svg" version="1.1">\n` +
                           `  <title>${paletteName}</title>\n` +
                           `  <desc>Palette generated by Palette Perfect</desc>\n` +
                           `${svgRects}\n` +
                           `</svg>`;
        const sanitizedPaletteName = paletteName.toLowerCase().replace(/[^a-z0-9_]+/g, '-');
        this._downloadFile(`${sanitizedPaletteName}-palette.svg`, svgContent, 'image/svg+xml;charset=utf-8;');
    },

    exportAsTextList: function(palette, paletteName = 'my-palette') {
        if (!Array.isArray(palette) || palette.length === 0) {
            console.error("Cannot export empty or invalid palette as Text List.");
            return;
        }
        const colorsList = palette.map(colorObj => (colorObj.hex || colorObj).toUpperCase()).join('\n');
        const textContent = `# ${paletteName}\n\n${colorsList}`;
        const sanitizedPaletteName = paletteName.toLowerCase().replace(/[^a-z0-9_]+/g, '-');
        this._downloadFile(`${sanitizedPaletteName}-palette.txt`, textContent, 'text/plain;charset=utf-8;');
    }
};