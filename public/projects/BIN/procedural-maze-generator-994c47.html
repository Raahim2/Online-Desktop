<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Procedural Maze Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Minimal custom styles */
        canvas:focus { outline: 2px solid #3B82F6; } /* blue-500 focus ring */
        html, body { height: 100%; margin: 0; scroll-behavior: smooth; }
        body { display: flex; flex-direction: column; }
        main { flex-grow: 1; }
        /* Style range input */
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 20px; height: 20px; background: #3B82F6; cursor: pointer; border-radius: 50%; }
        input[type=range]::-moz-range-thumb { width: 20px; height: 20px; background: #3B82F6; cursor: pointer; border-radius: 50%; border: none; }
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 font-sans flex flex-col min-h-screen text-gray-800 dark:text-gray-200">

    <header class="bg-gray-800 dark:bg-gray-950 text-white p-4 shadow-md sticky top-0 z-10">
        <h1 class="text-center text-xl sm:text-2xl font-bold tracking-tight">Procedural Maze Generator</h1>
    </header>

    <main class="flex-grow container mx-auto p-4 md:p-6 lg:p-8 flex flex-col lg:flex-row gap-6 lg:gap-8">

        <!-- Controls Section -->
        <aside id="controls" class="bg-white dark:bg-gray-800 p-5 md:p-6 rounded-lg shadow-lg lg:w-1/4 order-2 lg:order-1 flex flex-col gap-5 h-fit lg:sticky lg:top-24">
            <h2 class="text-xl font-semibold text-gray-700 dark:text-gray-300 border-b border-gray-300 dark:border-gray-600 pb-3">Controls</h2>

            <!-- Size Control -->
            <div>
                <label for="sizeSlider" class="block text-sm font-medium text-gray-600 dark:text-gray-400 mb-2">Maze Size:</label>
                <div class="flex items-center gap-3">
                     <input type="range" id="sizeSlider" name="sizeSlider" min="5" max="60" value="15" class="w-full h-2 bg-gray-200 dark:bg-gray-700 rounded-lg appearance-none cursor-pointer accent-blue-600 dark:accent-blue-500">
                     <span id="sizeValueLabel" class="text-sm font-semibold text-gray-700 dark:text-gray-300 w-12 text-right tabular-nums">15x15</span>
                </div>
            </div>

            <!-- Regenerate Button -->
            <button id="generateBtn" class="w-full bg-blue-600 hover:bg-blue-700 dark:bg-blue-700 dark:hover:bg-blue-800 text-white font-bold py-2.5 px-4 rounded-lg transition duration-200 ease-in-out focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 shadow-sm">
                Generate New Maze
            </button>

             <!-- Status/Message Area -->
            <div class="mt-2 text-center min-h-[40px] flex items-center justify-center">
                 <p id="messageDisplay" class="text-sm text-gray-600 dark:text-gray-400"></p>
            </div>

        </aside>

        <!-- Maze Area Section -->
        <section id="maze-area" class="bg-white dark:bg-gray-800 p-4 md:p-5 rounded-lg shadow-lg lg:w-3/4 order-1 lg:order-2 flex flex-col items-center flex-grow">
            <div class="flex justify-between items-center w-full mb-4 px-1">
                 <h2 class="text-xl font-semibold text-gray-700 dark:text-gray-300">Maze</h2>
                 <div class="flex items-center gap-2 bg-gray-100 dark:bg-gray-700 px-3 py-1 rounded-full shadow-inner">
                     <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-gray-500 dark:text-gray-400" viewBox="0 0 20 20" fill="currentColor">
                         <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.414-1.414L11 10.586V6z" clip-rule="evenodd" />
                     </svg>
                     <span id="timerDisplay" class="text-lg font-mono font-semibold text-gray-700 dark:text-gray-300 tabular-nums">00:00</span>
                 </div>
            </div>
            <div id="mazeCanvasContainer" class="w-full aspect-square max-w-full max-h-[calc(100vh-250px)] md:max-h-[calc(100vh-200px)] overflow-hidden flex items-center justify-center bg-gray-50 dark:bg-gray-700 rounded border border-gray-300 dark:border-gray-600 shadow-inner">
                 <canvas id="mazeCanvas" class="max-w-full max-h-full block rounded" tabindex="0">
                     Your browser does not support the canvas element. Please use a modern browser.
                 </canvas>
            </div>
             <p class="mt-3 text-xs text-gray-500 dark:text-gray-400 italic">Click the maze or use arrow keys to navigate.</p>
        </section>

    </main>

    <footer class="bg-gray-200 dark:bg-gray-800 text-center text-xs text-gray-600 dark:text-gray-400 p-3 mt-8">
        Procedural Maze Generator - Built with HTML, Tailwind CSS, and JavaScript.
    </footer>

    <script>
        // --- Constants ---
        const DEFAULT_SIZE = 15;
        const WALL_COLOR = '#374151'; // gray-700
        const PATH_COLOR_LIGHT = '#F9FAFB'; // gray-50 (canvas background light mode)
        const PATH_COLOR_DARK = '#4B5563'; // gray-600 (canvas background dark mode)
        const START_COLOR = '#10B981'; // emerald-500
        const END_COLOR = '#EF4444'; // red-500
        const PLAYER_COLOR = '#3B82F6'; // blue-500
        const PLAYER_BORDER_COLOR = '#1E40AF'; // dark blue-800
        const WALL_LINE_WIDTH_FACTOR = 0.1; // Line width relative to cell size
        const PLAYER_SIZE_FACTOR = 0.6; // Player size relative to cell size (diameter)
        const MARKER_SIZE_FACTOR = 0.7; // Start/End marker size relative to cell size

        // --- DOM Elements ---
        let canvas, ctx;
        let sizeSlider, sizeValueLabel;
        let generateBtn;
        let timerDisplay;
        let messageDisplay;
        let mazeCanvasContainer;

        // --- Maze State ---
        let maze = [];
        let mazeWidth, mazeHeight;
        let playerPos = { x: 0, y: 0 };
        let startPos = { x: 0, y: 0 };
        let endPos = { x: 0, y: 0 };
        let dynamicCellSize = 20; // Will be calculated

        // --- Timer State ---
        let timerInterval = null;
        let startTime = 0;
        let elapsedTime = 0; // In seconds
        let gameActive = false;
        let gameWon = false;

        // --- Debounce Timer ---
        let resizeTimeout;

        // --- Functions ---
        function init() {
            canvas = document.getElementById('mazeCanvas');
            if (!canvas.getContext) {
                // Handle browsers that don't support canvas
                mazeCanvasContainer.innerHTML = '<p class="text-red-500 text-center">Canvas not supported by your browser.</p>';
                return;
            }
            ctx = canvas.getContext('2d');
            sizeSlider = document.getElementById('sizeSlider');
            sizeValueLabel = document.getElementById('sizeValueLabel');
            generateBtn = document.getElementById('generateBtn');
            timerDisplay = document.getElementById('timerDisplay');
            messageDisplay = document.getElementById('messageDisplay');
            mazeCanvasContainer = document.getElementById('mazeCanvasContainer');

            // Event Listeners
            sizeSlider.addEventListener('input', handleSizeChange);
            generateBtn.addEventListener('click', () => {
                const size = parseInt(sizeSlider.value);
                generateMaze(size, size);
            });
            window.addEventListener('keydown', handleKeyDown);
            canvas.addEventListener('click', () => canvas.focus()); // Focus canvas on click
            window.addEventListener('resize', handleResize);

            // Initial setup
            handleSizeChange(); // Set initial label
            generateMaze(DEFAULT_SIZE, DEFAULT_SIZE);
            updateColorScheme(); // Set initial path color based on theme
        }

        function handleSizeChange() {
            const size = sizeSlider.value;
            sizeValueLabel.textContent = `${size}x${size}`;
            // Debounced generation on slider change (optional - can be intensive)
            // clearTimeout(resizeTimeout);
            // resizeTimeout = setTimeout(() => generateMaze(parseInt(size), parseInt(size)), 300);
        }

        function handleResize() {
             clearTimeout(resizeTimeout);
             resizeTimeout = setTimeout(() => {
                 if (maze.length > 0) {
                      setupCanvas(); // Recalculate dimensions
                      drawMaze();    // Redraw with new cell size
                 }
             }, 150); // Debounce resize event
        }

        function getPathColor() {
             // Check for dark mode preference
             if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                 return PATH_COLOR_DARK;
             }
             return PATH_COLOR_LIGHT;
        }

        function updateColorScheme() {
            // Redraw maze if path color needs to change based on theme
            if (maze.length > 0) {
                drawMaze();
            }
        }
        // Listen for changes in color scheme
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', updateColorScheme);


        function setupCanvas() {
            const containerWidth = mazeCanvasContainer.clientWidth;
            const containerHeight = mazeCanvasContainer.clientHeight;

            // Calculate cell size based on the smaller dimension and maze size
            dynamicCellSize = Math.max(1, Math.floor(Math.min(containerWidth / mazeWidth, containerHeight / mazeHeight)));

            canvas.width = mazeWidth * dynamicCellSize;
            canvas.height = mazeHeight * dynamicCellSize;

            // Ensure canvas doesn't exceed container (mostly for safety)
            canvas.style.maxWidth = `${containerWidth}px`;
            canvas.style.maxHeight = `${containerHeight}px`;
        }

        function generateMaze(width, height) {
            resetGame();
            mazeWidth = width;
            mazeHeight = height;
            maze = createGrid(width, height);
            startPos = { x: 0, y: 0 };
            endPos = { x: width - 1, y: height - 1 };
            playerPos = { ...startPos };

            const stack = [];
            if (!maze[startPos.y] || !maze[startPos.y][startPos.x]) {
                console.error("Invalid maze dimensions or start position.");
                messageDisplay.textContent = "Error: Invalid size.";
                return;
            }
            const startCell = maze[startPos.y][startPos.x];
            startCell.visited = true;
            stack.push(startCell);

            // DFS Recursive Backtracker Algorithm
            while (stack.length > 0) {
                const current = stack[stack.length - 1]; // Peek
                const neighbors = getUnvisitedNeighbors(current);

                if (neighbors.length > 0) {
                    const chosen = neighbors[Math.floor(Math.random() * neighbors.length)];
                    removeWall(current, chosen);
                    chosen.visited = true;
                    stack.push(chosen);
                } else {
                    stack.pop(); // Backtrack
                }
            }

            messageDisplay.textContent = 'Maze generated! Use arrow keys or click maze to start.';
            setupCanvas();
            drawMaze();
            canvas.focus(); // Focus canvas after generation
        }

         function resetGame() {
            stopTimer();
            elapsedTime = 0;
            gameActive = false;
            gameWon = false;
            playerPos = { ...startPos }; // Reset player to start (will be updated in generateMaze)
            updateTimerDisplay();
            messageDisplay.textContent = '';
        }

        function createGrid(width, height) {
            const grid = [];
            for (let y = 0; y < height; y++) {
                grid[y] = [];
                for (let x = 0; x < width; x++) {
                    grid[y][x] = {
                        x, y,
                        walls: { top: true, right: true, bottom: true, left: true },
                        visited: false
                    };
                }
            }
            return grid;
        }

        function getUnvisitedNeighbors(cell) {
            const { x, y } = cell;
            const neighbors = [];
            // Check boundaries and visited status robustly
            if (y > 0 && maze[y - 1]?.[x] && !maze[y - 1][x].visited) neighbors.push(maze[y - 1][x]); // Top
            if (x < mazeWidth - 1 && maze[y]?.[x + 1] && !maze[y][x + 1].visited) neighbors.push(maze[y][x + 1]); // Right
            if (y < mazeHeight - 1 && maze[y + 1]?.[x] && !maze[y + 1][x].visited) neighbors.push(maze[y + 1][x]); // Bottom
            if (x > 0 && maze[y]?.[x - 1] && !maze[y][x - 1].visited) neighbors.push(maze[y][x - 1]); // Left
            return neighbors;
        }

        function removeWall(cellA, cellB) {
            const dx = cellA.x - cellB.x;
            const dy = cellA.y - cellB.y;

            if (dx === 1) { // cellA is right of cellB
                cellA.walls.left = false;
                cellB.walls.right = false;
            } else if (dx === -1) { // cellA is left of cellB
                cellA.walls.right = false;
                cellB.walls.left = false;
            }

            if (dy === 1) { // cellA is below cellB
                cellA.walls.top = false;
                cellB.walls.bottom = false;
            } else if (dy === -1) { // cellA is above cellB
                cellA.walls.bottom = false;
                cellB.walls.top = false;
            }
        }

        function drawMaze() {
            if (!ctx || !maze || maze.length === 0 || dynamicCellSize <= 0) return;

            const pathColor = getPathColor();
            ctx.fillStyle = pathColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw Walls
            ctx.strokeStyle = WALL_COLOR;
            ctx.lineWidth = Math.max(1, Math.floor(dynamicCellSize * WALL_LINE_WIDTH_FACTOR));
            ctx.lineCap = 'round'; // Nicer line endings
            ctx.beginPath();

            for (let y = 0; y < mazeHeight; y++) {
                for (let x = 0; x < mazeWidth; x++) {
                    const cell = maze[y][x];
                    const cellX = x * dynamicCellSize;
                    const cellY = y * dynamicCellSize;

                    // Draw only necessary walls for performance
                    if (cell.walls.top) {
                        ctx.moveTo(cellX, cellY);
                        ctx.lineTo(cellX + dynamicCellSize, cellY);
                    }
                    if (cell.walls.right) {
                        ctx.moveTo(cellX + dynamicCellSize, cellY);
                        ctx.lineTo(cellX + dynamicCellSize, cellY + dynamicCellSize);
                    }
                    // Avoid double drawing bottom/left by only drawing top/right
                    // Or draw all and accept minor overlap
                    if (cell.walls.bottom) {
                         ctx.moveTo(cellX + dynamicCellSize, cellY + dynamicCellSize);
                         ctx.lineTo(cellX, cellY + dynamicCellSize);
                    }
                    if (cell.walls.left) {
                         ctx.moveTo(cellX, cellY + dynamicCellSize);
                         ctx.lineTo(cellX, cellY);
                    }
                }
            }
            ctx.stroke();

            // Draw Start and End points
            const markerSize = dynamicCellSize * MARKER_SIZE_FACTOR;
            const offset = (dynamicCellSize - markerSize) / 2; // Center the marker

            ctx.fillStyle = START_COLOR;
            ctx.fillRect(startPos.x * dynamicCellSize + offset, startPos.y * dynamicCellSize + offset, markerSize, markerSize);

            ctx.fillStyle = END_COLOR;
            ctx.fillRect(endPos.x * dynamicCellSize + offset, endPos.y * dynamicCellSize + offset, markerSize, markerSize);

            drawPlayer();
        }

        function drawPlayer() {
             if (!ctx || dynamicCellSize <= 0) return;
             const playerDiameter = dynamicCellSize * PLAYER_SIZE_FACTOR;
             const playerRadius = playerDiameter / 2;
             const playerCenterX = playerPos.x * dynamicCellSize + dynamicCellSize / 2;
             const playerCenterY = playerPos.y * dynamicCellSize + dynamicCellSize / 2;

             // Draw player circle
             ctx.fillStyle = PLAYER_COLOR;
             ctx.beginPath();
             ctx.arc(playerCenterX, playerCenterY, playerRadius, 0, Math.PI * 2);
             ctx.fill();

             // Draw player border
             ctx.strokeStyle = PLAYER_BORDER_COLOR;
             ctx.lineWidth = Math.max(1, Math.floor(dynamicCellSize * 0.05)); // Thin border
             ctx.stroke();
        }

        // Optimized redraw for player movement
        function redrawPlayerMovement(oldPos, newPos) {
            if (!ctx || dynamicCellSize <= 0) return;
            const pathColor = getPathColor();
            const markerSize = dynamicCellSize * MARKER_SIZE_FACTOR;
            const offset = (dynamicCellSize - markerSize) / 2;

            // Clear old player position area
            ctx.fillStyle = pathColor;
            ctx.fillRect(oldPos.x * dynamicCellSize, oldPos.y * dynamicCellSize, dynamicCellSize, dynamicCellSize);

            // Redraw walls around old cell
            redrawCellWalls(oldPos.x, oldPos.y);
            // Redraw walls for neighbors of old cell if needed (can get complex)

            // Redraw start/end if old position was on it
            if (oldPos.x === startPos.x && oldPos.y === startPos.y) {
                 ctx.fillStyle = START_COLOR;
                 ctx.fillRect(startPos.x * dynamicCellSize + offset, startPos.y * dynamicCellSize + offset, markerSize, markerSize);
            }
             if (oldPos.x === endPos.x && oldPos.y === endPos.y) {
                 ctx.fillStyle = END_COLOR;
                 ctx.fillRect(endPos.x * dynamicCellSize + offset, endPos.y * dynamicCellSize + offset, markerSize, markerSize);
            }

            // Clear new player position area (to ensure clean background)
             ctx.fillStyle = pathColor;
             ctx.fillRect(newPos.x * dynamicCellSize, newPos.y * dynamicCellSize, dynamicCellSize, dynamicCellSize);

            // Redraw walls around new cell
             redrawCellWalls(newPos.x, newPos.y);

             // Redraw start/end if new position is on it
             if (newPos.x === startPos.x && newPos.y === startPos.y) {
                 ctx.fillStyle = START_COLOR;
                 ctx.fillRect(startPos.x * dynamicCellSize + offset, startPos.y * dynamicCellSize + offset, markerSize, markerSize);
             }
             if (newPos.x === endPos.x && newPos.y === endPos.y) {
                 ctx.fillStyle = END_COLOR;
                 ctx.fillRect(endPos.x * dynamicCellSize + offset, endPos.y * dynamicCellSize + offset, markerSize, markerSize);
             }

            // Draw player at new position
            drawPlayer();
        }

        // Helper to redraw walls for a specific cell
        function redrawCellWalls(x, y) {
            if (!ctx || !maze?.[y]?.[x] || dynamicCellSize <= 0) return;
            const cell = maze[y][x];
            const cellX = x * dynamicCellSize;
            const cellY = y * dynamicCellSize;

            ctx.strokeStyle = WALL_COLOR;
            ctx.lineWidth = Math.max(1, Math.floor(dynamicCellSize * WALL_LINE_WIDTH_FACTOR));
            ctx.lineCap = 'round';
            ctx.beginPath();

            if (cell.walls.top) { ctx.moveTo(cellX, cellY); ctx.lineTo(cellX + dynamicCellSize, cellY); }
            if (cell.walls.right) { ctx.moveTo(cellX + dynamicCellSize, cellY); ctx.lineTo(cellX + dynamicCellSize, cellY + dynamicCellSize); }
            if (cell.walls.bottom) { ctx.moveTo(cellX + dynamicCellSize, cellY + dynamicCellSize); ctx.lineTo(cellX, cellY + dynamicCellSize); }
            if (cell.walls.left) { ctx.moveTo(cellX, cellY + dynamicCellSize); ctx.lineTo(cellX, cellY); }
            ctx.stroke();
        }


        function handleKeyDown(e) {
             const validKeys = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'w', 'a', 's', 'd'];
             if (!validKeys.includes(e.key.toLowerCase())) return; // Ignore other keys

             // Prevent default scrolling behavior for arrow keys
             e.preventDefault();

             if (gameWon) return; // No movement after winning

             // Start game on first valid move
             if (!gameActive) {
                 startGame();
             }

             if (!gameActive) return; // Should not happen if startGame worked, but safety check

             if (!maze?.[playerPos.y]?.[playerPos.x]) {
                 console.error("Error: Current player position is invalid.");
                 return; // Abort if maze/player data is corrupt
             }
             const currentCell = maze[playerPos.y][playerPos.x];
             let moved = false;
             let targetPos = { ...playerPos };

             switch (e.key.toLowerCase()) {
                 case 'arrowup':
                 case 'w':
                     if (!currentCell.walls.top) { targetPos.y -= 1; moved = true; }
                     break;
                 case 'arrowdown':
                 case 's':
                     if (!currentCell.walls.bottom) { targetPos.y += 1; moved = true; }
                     break;
                 case 'arrowleft':
                 case 'a':
                     if (!currentCell.walls.left) { targetPos.x -= 1; moved = true; }
                     break;
                 case 'arrowright':
                 case 'd':
                     if (!currentCell.walls.right) { targetPos.x += 1; moved = true; }
                     break;
             }

             if (moved) {
                 const oldPos = { ...playerPos };
                 playerPos = targetPos; // Update player position state
                 // Use optimized redraw instead of full drawMaze()
                 redrawPlayerMovement(oldPos, playerPos);
                 // drawMaze(); // Fallback: Redraw everything (simpler but slower)
                 checkWinCondition();
             }
        }

        function startGame() {
            if (gameActive || gameWon) return;
            gameActive = true;
            startTime = Date.now() - (elapsedTime * 1000); // Resume timer correctly
            messageDisplay.textContent = 'Solving... Use arrow keys!';

            if (timerInterval) clearInterval(timerInterval); // Clear existing interval if any

            updateTimerDisplay(); // Show current time immediately
            timerInterval = setInterval(() => {
                if (gameActive) {
                    elapsedTime = Math.floor((Date.now() - startTime) / 1000);
                    updateTimerDisplay();
                } else {
                     // This case handles stopping if gameActive becomes false externally
                     clearInterval(timerInterval);
                     timerInterval = null;
                }
            }, 1000);
            canvas.focus(); // Ensure canvas has focus for key events
        }

        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            // Note: Doesn't set gameActive = false here, that happens on win or reset
        }

        function checkWinCondition() {
            if (playerPos.x === endPos.x && playerPos.y === endPos.y) {
                gameWon = true;
                gameActive = false; // Stop further movement and timer updates logic
                stopTimer();
                const timeFormatted = formatTime(elapsedTime);
                messageDisplay.innerHTML = `ðŸŽ‰ <span class="font-semibold">Solved in ${timeFormatted}!</span> ðŸŽ‰`; // Use innerHTML for emoji
                // Optional: Visual feedback like flashing the end square
                flashEndSquare(3);
            }
        }

        function flashEndSquare(flashes) {
            let count = 0;
            const interval = setInterval(() => {
                const markerSize = dynamicCellSize * MARKER_SIZE_FACTOR;
                const offset = (dynamicCellSize - markerSize) / 2;
                const x = endPos.x * dynamicCellSize + offset;
                const y = endPos.y * dynamicCellSize + offset;

                // Toggle color
                ctx.fillStyle = (count % 2 === 0) ? '#FFFFFF' : END_COLOR; // Flash white/red
                ctx.fillRect(x, y, markerSize, markerSize);
                drawPlayer(); // Ensure player is redrawn on top if they are on the end square

                count++;
                if (count >= flashes * 2) {
                    clearInterval(interval);
                    // Ensure final state is correct color
                    ctx.fillStyle = END_COLOR;
                    ctx.fillRect(x, y, markerSize, markerSize);
                    drawPlayer();
                }
            }, 150); // Flash speed
        }


        function updateTimerDisplay() {
            timerDisplay.textContent = formatTime(elapsedTime);
        }

        function formatTime(totalSeconds) {
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }

        // --- Initialization ---
        // Wait for the DOM to be fully loaded before running the script
        document.addEventListener('DOMContentLoaded', init);

    </script>

</body>
</html>