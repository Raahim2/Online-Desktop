<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cute Animal Memory Match</title>
    <!-- Include Tailwind CSS via CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Add custom styles needed for the 3D flip effect */
        .card {
            transform-style: preserve-3d;
            transition: transform 0.6s;
        }
        .card.flipped {
            transform: rotateY(180deg);
        }
        .card-face {
            backface-visibility: hidden;
            position: absolute;
            inset: 0; /* Equivalent to top/right/bottom/left: 0 */
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 0.5rem; /* Match rounded-lg */
        }
        .card-front {
            transform: rotateY(180deg);
        }
        /* Prevent clicking during flip back animation */
        .no-pointer {
           pointer-events: none;
        }
    </style>
</head>
<body class="bg-gradient-to-br from-pink-200 via-purple-200 to-indigo-300 min-h-screen flex items-center justify-center p-4">

    <main class="bg-white/80 backdrop-blur-sm rounded-xl shadow-lg p-6 w-full max-w-2xl">
        <header class="flex flex-col sm:flex-row justify-between items-center mb-6 pb-4 border-b border-gray-300">
            <h1 class="text-2xl sm:text-3xl font-bold text-gray-800 mb-3 sm:mb-0">Animal Memory Match</h1>
            <div class="flex items-center space-x-4">
                <p class="text-lg text-gray-700">Score: <span id="score" class="font-semibold">0</span></p>
                <button id="new-game-button" class="px-4 py-2 bg-pink-500 hover:bg-pink-600 text-white rounded-md font-semibold transition duration-200 ease-in-out shadow-sm">
                    New Game
                </button>
            </div>
        </header>

        <div id="game-board" class="grid grid-cols-4 gap-3 sm:gap-4 aspect-[4/3] sm:aspect-[3/2] md:aspect-[4/3]">
            <!-- Cards will be generated here by JavaScript -->
        </div>

        <!-- Win Message Overlay (Hidden initially) -->
        <div id="win-message" class="fixed inset-0 bg-black/50 flex items-center justify-center hidden z-50 p-4">
            <div class="bg-white rounded-lg shadow-xl p-8 text-center">
                <h2 class="text-3xl font-bold text-green-600 mb-4">Congratulations!</h2>
                <p class="text-xl text-gray-700 mb-6">You matched all the animals in <span id="final-score" class="font-bold">0</span> moves!</p>
                <button id="play-again-button" class="px-6 py-3 bg-pink-500 hover:bg-pink-600 text-white rounded-md font-semibold transition duration-200 ease-in-out text-lg">
                    Play Again
                </button>
            </div>
        </div>
    </main>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const gameBoard = document.getElementById('game-board');
            const scoreDisplay = document.getElementById('score');
            const newGameButton = document.getElementById('new-game-button');
            const winMessage = document.getElementById('win-message');
            const finalScoreDisplay = document.getElementById('final-score');
            const playAgainButton = document.getElementById('play-again-button');

            // Define pairs of animals (Emoji & unique ID)
            // Using emojis for simplicity, replace with <img> tags if specific illustrations are required
            const animalPairs = [
                { id: 'cat', emoji: 'ðŸ±', color: 'bg-yellow-300' },
                { id: 'dog', emoji: 'ðŸ¶', color: 'bg-orange-300' },
                { id: 'pig', emoji: 'ðŸ·', color: 'bg-pink-300' },
                { id: 'frog', emoji: 'ðŸ¸', color: 'bg-green-400' },
                { id: 'bear', emoji: 'ðŸ»', color: 'bg-amber-700/60' }, // Using brown-ish
                { id: 'panda', emoji: 'ðŸ¼', color: 'bg-gray-300' },
                { id: 'rabbit', emoji: 'ðŸ°', color: 'bg-stone-300' },
                { id: 'fox', emoji: 'ðŸ¦Š', color: 'bg-red-400' }
            ];

            let cardsData = [];
            let flippedCards = [];
            let matchedPairs = 0;
            let score = 0;
            let canFlip = true; // Prevent flipping more than 2 or during animation

            // --- Fisher-Yates Shuffle Algorithm ---
            function shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]]; // Swap elements
                }
                return array;
            }

            // --- Create Card HTML Element ---
            function createCardElement(cardInfo) {
                const card = document.createElement('div');
                card.classList.add('card', 'relative', 'w-full', 'h-full', 'cursor-pointer', 'rounded-lg', 'shadow-md', 'transform-style-preserve-3d');
                card.dataset.id = cardInfo.id; // Store the identifier

                // Card Back (Visible initially)
                const cardBack = document.createElement('div');
                cardBack.classList.add('card-face', 'card-back', 'bg-gradient-to-br', 'from-purple-400', 'to-indigo-500', 'text-white', 'text-3xl', 'font-bold', 'backface-hidden');
                cardBack.textContent = '?'; // Simple back content

                // Card Front (Hidden initially, shows animal)
                const cardFront = document.createElement('div');
                cardFront.classList.add('card-face', 'card-front', cardInfo.color, 'text-4xl', 'sm:text-5xl', 'backface-hidden', 'rotate-y-180');
                cardFront.textContent = cardInfo.emoji;

                card.appendChild(cardBack);
                card.appendChild(cardFront);

                card.addEventListener('click', handleCardClick);
                return card;
            }

            // --- Handle Card Click Logic ---
            function handleCardClick() {
                if (!canFlip || this.classList.contains('flipped') || this.classList.contains('matched') || flippedCards.length >= 2) {
                    return; // Ignore click if not allowed, card already flipped/matched, or 2 already selected
                }

                this.classList.add('flipped', 'no-pointer'); // Flip the card and disable pointer events temporarily
                flippedCards.push(this);

                if (flippedCards.length === 2) {
                    incrementScore();
                    checkForMatch();
                }
            }

            // --- Check if Flipped Cards Match ---
            function checkForMatch() {
                canFlip = false; // Disable flipping while checking
                const [card1, card2] = flippedCards;
                const isMatch = card1.dataset.id === card2.dataset.id;

                if (isMatch) {
                    // It's a match!
                    setTimeout(() => { // Short delay for visual confirmation
                        card1.classList.add('matched');
                        card2.classList.add('matched');
                        // Keep no-pointer on matched cards
                        matchedPairs++;
                        flippedCards = []; // Reset flipped cards array
                        canFlip = true; // Allow flipping again
                        checkWinCondition();
                    }, 300); // Shorter delay for matches
                } else {
                    // Not a match
                    setTimeout(() => {
                        card1.classList.remove('flipped', 'no-pointer'); // Flip back and re-enable pointer
                        card2.classList.remove('flipped', 'no-pointer');
                        flippedCards = []; // Reset flipped cards array
                        canFlip = true; // Allow flipping again
                    }, 1000); // Wait 1 second before flipping back
                }
            }

            // --- Increment Score ---
            function incrementScore() {
                score++;
                scoreDisplay.textContent = score;
            }

            // --- Check for Win Condition ---
            function checkWinCondition() {
                if (matchedPairs === animalPairs.length) {
                    finalScoreDisplay.textContent = score;
                    winMessage.classList.remove('hidden');
                    // Optionally disable the board further
                    gameBoard.classList.add('pointer-events-none');
                }
            }

            // --- Initialize/Reset Game ---
            function initGame() {
                // Reset state
                flippedCards = [];
                matchedPairs = 0;
                score = 0;
                canFlip = true;
                scoreDisplay.textContent = '0';
                winMessage.classList.add('hidden'); // Hide win message
                gameBoard.innerHTML = ''; // Clear previous cards
                gameBoard.classList.remove('pointer-events-none'); // Re-enable board clicks

                // Create card data (duplicate pairs)
                cardsData = [...animalPairs, ...animalPairs];

                // Shuffle and Create Cards
                shuffleArray(cardsData);
                cardsData.forEach(cardInfo => {
                    const cardElement = createCardElement(cardInfo);
                    gameBoard.appendChild(cardElement);
                });
            }

            // --- Event Listeners ---
            newGameButton.addEventListener('click', initGame);
            playAgainButton.addEventListener('click', initGame); // Play Again also calls initGame

            // --- Start the game on initial load ---
            initGame();
        });
    </script>

</body>
</html>
```

**Explanation:**

1.  **HTML Structure:**
    *   Standard HTML5 boilerplate.
    *   Includes Tailwind CSS via CDN in the `<head>`.
    *   A `<style>` block is added for the CSS properties essential for the 3D flip effect (`transform-style`, `backface-visibility`, `transition`) which, while potentially possible with complex Tailwind config or JIT mode, are simpler to define directly here for broad compatibility. Utility classes like `.card`, `.flipped`, `.card-face`, `.card-front`, `.card-back`, and `.no-pointer` are defined.
    *   The `<body>` has a gradient background and uses flexbox to center the main game container.
    *   The `<main>` container holds the game content, styled with Tailwind for background, padding, rounded corners, and shadow.
    *   The `<header>` contains the title, score display (`<span id="score">`), and the "New Game" button (`<button id="new-game-button">`). It uses flexbox for layout and responsiveness.
    *   The `<div id="game-board">` is where cards will be placed. It uses Tailwind's `grid` and `gap` utilities. `aspect-ratio` classes help maintain shape, adjusting slightly for different screen sizes (`aspect-[4/3]`, etc.).
    *   A hidden `div` (`#win-message`) acts as a modal/overlay to display the win condition and final score.
    *   The entire JavaScript logic is contained within a single `<script>` tag at the end of the `<body>`, ensuring the HTML elements exist before the script tries to access them.

2.  **Tailwind CSS Styling:**
    *   Extensive use of Tailwind utility classes for layout (`flex`, `grid`, `justify-between`, `items-center`), spacing (`p-4`, `mb-6`, `gap-4`), colors (`bg-pink-200`, `text-gray-800`, `bg-pink-500`), typography (`text-2xl`, `font-bold`), borders (`rounded-lg`), shadows (`shadow-lg`), and transitions (`transition`, `duration-200`).
    *   Responsive prefixes (`sm:`, `md:`) are used to adjust layout and sizing on different screen sizes (e.g., header flex direction, card text size, grid aspect ratio).
    *   The card back has a gradient (`bg-gradient-to-br from-purple-400 to-indigo-500`).
    *   The card front's background color (`cardInfo.color`) is dynamically assigned from the `animalPairs` data using Tailwind background color classes (e.g., `bg-yellow-300`).

3.  **JavaScript Logic (Inline):**
    *   **`DOMContentLoaded` Listener:** Ensures the script runs only after the HTML is fully parsed.
    *   **Constants & Variables:** References to DOM elements, the `animalPairs` data structure, and game state variables (`cardsData`, `flippedCards`, `matchedPairs`, `score`, `canFlip`).
    *   **`shuffleArray`:** Implements the Fisher-Yates algorithm to randomize the card order.
    *   **`createCardElement`:** Dynamically generates the HTML for each card (container, front, back), applies Tailwind classes, sets the `data-id` attribute for matching logic, and attaches the click event listener. Uses the `cardInfo` object passed to it.
    *   **`handleCardClick`:** Triggered when a card is clicked. It checks game rules (if flipping is allowed, if the card is already revealed, if 2 cards are already flipped), flips the card by adding the `.flipped` class, adds it to the `flippedCards` array, and calls `checkForMatch` if two cards are now flipped. It adds `.no-pointer` to prevent clicks on the flipped card.
    *   **`checkForMatch`:** Compares the `data-id` of the two cards in `flippedCards`.
        *   If they match: Marks them with a `.matched` class (though just leaving them flipped and with `.no-pointer` works), increments `matchedPairs`, clears `flippedCards`, allows flipping again (`canFlip = true`), and checks for the win condition. A short `setTimeout` is used for visual feedback before locking.
        *   If they don't match: Uses `setTimeout` to pause briefly (1 second) before removing the `.flipped` class and `.no-pointer` from both cards, clearing `flippedCards`, and allowing flipping again.
    *   **`incrementScore`:** Updates the `score` variable and the text content of the `#score` span.
    *   **`checkWinCondition`:** Checks if `matchedPairs` equals the total number of unique pairs. If true, it displays the win message overlay (`#win-message`) with the final score.
    *   **`initGame`:** Resets all game state variables, clears the board, generates the `cardsData` array (duplicating the `animalPairs`), shuffles it, creates and appends the new card elements to the board, and hides the win message.
    *   **Event Listeners:** Attaches the `initGame` function to the "New Game" and "Play Again" buttons.
    *   **Initial Call:** Calls `initGame()` once the DOM is ready to start the game immediately.
