<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Catch the Falling Objects</title>
    <!-- Tailwind CSS via CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles if needed, but aiming for pure Tailwind */
        body {
            font-family: 'Inter', sans-serif; /* Example font */
            overscroll-behavior: none; /* Prevent pull-to-refresh */
        }
        /* Ensure game area has a fixed coordinate system */
        #game-area {
            position: relative;
            overflow: hidden; /* Objects disappear cleanly if they go slightly out */
            touch-action: none; /* Prevent scrolling on touch devices within game area */
        }
        /* Base style for falling objects */
        .falling-object {
            position: absolute;
            width: 40px; /* Increased size for easier clicking */
            height: 40px;
            border-radius: 50%; /* Simple circles */
            cursor: pointer;
            user-select: none; /* Prevent text selection */
            will-change: top; /* Performance hint */
            transition: transform 0.1s ease-out; /* Slight visual feedback on click */
        }
        .falling-object:active {
            transform: scale(0.9); /* Scale down slightly when clicked */
        }

        /* Example object colors (can be randomized) */
        .object-red { background-color: #ef4444; } /* red-500 */
        .object-blue { background-color: #3b82f6; } /* blue-500 */
        .object-green { background-color: #22c55e; } /* green-500 */
        .object-yellow { background-color: #eab308; } /* yellow-500 */
        .object-purple { background-color: #a855f7; } /* purple-500 */

        /* Hide scrollbars */
        html, body {
            overflow: hidden;
        }
    </style>
    <!-- Optional: Google Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
</head>
<body class="bg-gradient-to-br from-sky-100 to-indigo-200 flex items-center justify-center min-h-screen p-4">

    <div id="game-container" class="bg-white rounded-xl shadow-2xl w-full max-w-lg aspect-[3/4] flex flex-col">

        <!-- Score Display -->
        <div class="p-4 border-b border-gray-200 flex justify-between items-center">
            <h1 class="text-xl font-bold text-gray-800">Catch 'Em!</h1>
            <div class="text-right">
                <span class="text-sm text-gray-500 block">Score</span>
                <span id="score-value" class="text-2xl font-bold text-indigo-600">0</span>
            </div>
        </div>

        <!-- Game Area -->
        <div id="game-area" class="flex-grow w-full h-full">
            <!-- Falling objects will be added here by JavaScript -->
        </div>

        <!-- Start/Game Over Screen -->
        <div id="overlay" class="absolute inset-0 bg-black bg-opacity-60 flex flex-col items-center justify-center z-10 rounded-xl text-center p-6" style="display: flex;">
             <!-- Centered within the game-container -->
            <div class="absolute top-0 left-0 right-0 bottom-0 flex flex-col items-center justify-center pointer-events-none">
                <h2 id="overlay-title" class="text-4xl font-bold text-white mb-4">Catch the Objects!</h2>
                <p id="overlay-message" class="text-lg text-gray-200 mb-6">Click the falling shapes before they hit the bottom.</p>
                <p id="final-score" class="text-2xl font-semibold text-yellow-400 mb-8" style="display: none;"></p>
                <button id="start-button" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-8 rounded-lg text-lg transition duration-200 ease-in-out transform hover:scale-105 pointer-events-auto">
                    Start Game
                </button>
            </div>
        </div>

    </div>

    <script>
        const gameArea = document.getElementById('game-area');
        const scoreValueElement = document.getElementById('score-value');
        const overlay = document.getElementById('overlay');
        const overlayTitle = document.getElementById('overlay-title');
        const overlayMessage = document.getElementById('overlay-message');
        const finalScoreElement = document.getElementById('final-score');
        const startButton = document.getElementById('start-button');

        let score = 0;
        let gameInterval = null;
        let spawnInterval = null;
        let gameActive = false;
        let objects = []; // To keep track of falling objects { element: DOMElement, speed: number }

        // Game parameters
        let baseSpeed = 1.5; // Initial pixels per frame (adjust for desired starting speed)
        let speedIncrease = 0.1; // How much speed increases per difficulty step
        let currentSpeed = baseSpeed;

        let baseSpawnRate = 1500; // Initial milliseconds between spawns
        let spawnRateDecrease = 100; // How much spawn interval decreases
        let minSpawnRate = 300; // Minimum spawn interval
        let currentSpawnRate = baseSpawnRate;

        let difficultyIncreaseInterval = 10; // Increase difficulty every X points

        const objectColors = ['object-red', 'object-blue', 'object-green', 'object-yellow', 'object-purple'];

        function getRandomColorClass() {
            return objectColors[Math.floor(Math.random() * objectColors.length)];
        }

        function updateScoreDisplay() {
            scoreValueElement.textContent = score;
        }

        function increaseDifficulty() {
            currentSpeed += speedIncrease;
            currentSpawnRate = Math.max(minSpawnRate, currentSpawnRate - spawnRateDecrease);

            // Update the spawn interval timer
            clearInterval(spawnInterval);
            if (gameActive) {
               spawnInterval = setInterval(spawnObject, currentSpawnRate);
            }
            console.log(`Difficulty Increased: Speed=${currentSpeed.toFixed(2)}, SpawnRate=${currentSpawnRate}ms`);
        }

        function spawnObject() {
            if (!gameActive) return;

            const objectElement = document.createElement('div');
            objectElement.classList.add('falling-object', getRandomColorClass());

            // Ensure object spawns fully within horizontal bounds
            const gameAreaWidth = gameArea.offsetWidth;
            const objectWidth = 40; // Must match CSS width
            const maxLeft = gameAreaWidth - objectWidth;
            const randomLeft = Math.random() * maxLeft;

            objectElement.style.left = `${randomLeft}px`;
            objectElement.style.top = `-40px`; // Start just above the visible area

            // Store object data
            const objectData = {
                element: objectElement,
                speed: currentSpeed, // Assign current speed to this object
                top: -40 // Store its logical top position
            };
            objects.push(objectData);

            // Add click listener to catch the object
            objectElement.addEventListener('click', (event) => {
                if (!gameActive) return; // Prevent scoring after game over

                event.stopPropagation(); // Prevent potential event issues

                score++;
                updateScoreDisplay();

                // Increase difficulty based on score milestones
                if (score > 0 && score % difficultyIncreaseInterval === 0) {
                    increaseDifficulty();
                }

                // Remove object visually and from tracking
                objectElement.remove();
                objects = objects.filter(obj => obj !== objectData);
            });

            gameArea.appendChild(objectElement);
        }

        function gameLoop() {
            if (!gameActive) return;

            const gameAreaHeight = gameArea.offsetHeight;

            // Move existing objects and check for game over
            for (let i = objects.length - 1; i >= 0; i--) {
                const obj = objects[i];
                obj.top += obj.speed; // Update logical position based on its speed when spawned
                obj.element.style.top = `${obj.top}px`; // Update visual position

                // Check if object reached the bottom
                if (obj.top + obj.element.offsetHeight >= gameAreaHeight) {
                    gameOver();
                    return; // Stop the loop immediately on game over
                }
            }

             // Request next frame
            requestAnimationFrame(gameLoop);
        }


        function resetGame() {
            // Clear intervals
            cancelAnimationFrame(gameInterval); // Use cancelAnimationFrame if using rAF
            clearInterval(spawnInterval);
            gameInterval = null;
            spawnInterval = null;

            // Reset variables
            score = 0;
            currentSpeed = baseSpeed;
            currentSpawnRate = baseSpawnRate;
            gameActive = false;

             // Clear existing objects from DOM and array
            objects.forEach(obj => obj.element.remove());
            objects = [];

            // Reset UI
            updateScoreDisplay();
            overlay.style.display = 'flex'; // Show overlay
            finalScoreElement.style.display = 'none'; // Hide final score initially
            overlayTitle.textContent = 'Catch the Objects!';
            overlayMessage.textContent = 'Click the falling shapes before they hit the bottom.';
            startButton.textContent = 'Start Game';
        }

        function startGame() {
            if (gameActive) return; // Prevent starting multiple times

            resetGame(); // Ensure clean state before starting
            gameActive = true;
            overlay.style.display = 'none'; // Hide overlay

            console.log("Game Started");
            // Start the spawn timer
            spawnInterval = setInterval(spawnObject, currentSpawnRate);

            // Start the game loop using requestAnimationFrame for smoother animation
             gameInterval = requestAnimationFrame(gameLoop);
        }

        function gameOver() {
            console.log("Game Over");
            gameActive = false;
            cancelAnimationFrame(gameInterval); // Use cancelAnimationFrame if using rAF
            clearInterval(spawnInterval);

            // Display Game Over screen
            overlay.style.display = 'flex';
            overlayTitle.textContent = 'Game Over!';
            overlayMessage.textContent = 'Nice try!';
            finalScoreElement.textContent = `Final Score: ${score}`;
            finalScoreElement.style.display = 'block';
            startButton.textContent = 'Play Again?';

            // Optional: Add a small delay before allowing restart to prevent accidental clicks
            startButton.disabled = true;
            setTimeout(() => {
                startButton.disabled = false;
            }, 500);
        }

        // Event Listener for Start/Restart Button
        startButton.addEventListener('click', startGame);

        // Initial setup
        resetGame(); // Prepare the game screen initially

        // Optional: Handle window resize (basic example: restart game)
        let resizeTimeout;
        window.addEventListener('resize', () => {
            // Debounce resize event
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                if (gameActive) {
                    // Simple approach: end the current game on resize
                    console.log("Window resized during game - Ending game.");
                    gameOver();
                    // More complex: could try to reposition objects, but restarting is easier
                }
                 // Ensure overlay fits correctly if it's displayed
                if (!gameActive) {
                    // Optional: You might want to adjust layout if needed when not active
                }
            }, 250); // Adjust debounce delay as needed
        });

    </script>

</body>
</html>
```

**Explanation:**

1.  **HTML Structure:**
    *   Standard HTML5 boilerplate.
    *   Includes Tailwind CSS via CDN.
    *   A simple `<style>` block is included for CSS properties not easily covered by Tailwind utility classes (like `will-change` for performance, `:active` pseudo-class for click feedback, specific object sizing, and `touch-action: none` for mobile).
    *   The main layout uses Flexbox (`flex`, `items-center`, `justify-center`) to center the `game-container`.
    *   `game-container`: The main box for the game, using Tailwind for background, rounding, shadow, max-width, and aspect ratio (`aspect-[3/4]`) to maintain a consistent shape.
    *   `Score Display`: Positioned at the top within the container.
    *   `game-area`: The crucial part where objects fall. It uses `flex-grow` to take up remaining space, `relative` positioning so objects inside can be positioned absolutely, and `overflow: hidden` to clip objects that go outside its bounds.
    *   `overlay`: An absolute positioned div that covers the `game-container`. It's used for both the initial start screen and the game over screen. Its visibility is controlled by JavaScript (`display: flex` or `display: none`). It uses `z-index-10` to appear above the game area.
    *   `Start Button`: Inside the overlay, styled with Tailwind.

2.  **Tailwind CSS Usage:**
    *   Utility classes are used extensively for layout (`flex`, `max-w-lg`, `aspect-[3/4]`), background (`bg-gradient-to-br`, `bg-white`), borders (`border-b`), rounding (`rounded-xl`), shadows (`shadow-2xl`), text (`text-xl`, `font-bold`, `text-indigo-600`), padding (`p-4`), margins (`mb-4`), etc.
    *   Object colors are defined as simple CSS classes (`.object-red`, etc.) but could also be done inline with Tailwind `bg-red-500`, etc., if preferred. Using classes makes random selection slightly cleaner in JS.

3.  **JavaScript Logic:**
    *   **Variables:** Keeps track of DOM elements, score, game state (`gameActive`), interval IDs, objects array, speed, and spawn rate parameters.
    *   **`objects` Array:** Stores objects currently on screen. Each entry is an object `{ element: DOMElement, speed: number, top: number }` containing the DOM node, its *assigned* speed (difficulty increases affect *new* objects), and its current logical `top` position.
    *   **`spawnObject()`:** Creates a new `div`, assigns base and color classes, calculates a random horizontal position (`left`), sets initial `top`, adds it to the `gameArea` and the `objects` array. Crucially, it adds a `click` listener to each object for scoring and removal.
    *   **`gameLoop()`:**
        *   Uses `requestAnimationFrame` for smooth animation synchronized with browser rendering (better than `setInterval` for animation).
        *   Iterates through the `objects` array.
        *   Updates each object's logical `top` position based on its stored `speed`.
        *   Updates the object's `style.top` to visually move it down.
        *   Checks if any object has reached or passed the bottom of the `gameArea`. If so, calls `gameOver()`.
        *   Schedules the next frame using `requestAnimationFrame(gameLoop)`.
    *   **`increaseDifficulty()`:** Called when score milestones are reached. Increases `currentSpeed` and decreases `currentSpawnRate` (with a minimum). It restarts the `spawnInterval` with the new rate.
    *   **`startGame()`:** Resets the game state, hides the overlay, resets score/difficulty, starts the `spawnInterval`, and initiates the `gameLoop` via `requestAnimationFrame`.
    *   **`gameOver()`:** Sets `gameActive` to false, stops the loop (`cancelAnimationFrame`) and spawning (`clearInterval`), shows the overlay with the final score, and updates the button text. Includes a small delay before re-enabling the button.
    *   **`resetGame()`:** Clears intervals, resets game variables and UI elements to their initial state, and removes any leftover object elements.
    *   **Event Listeners:** Attached to the `startButton` to initiate the game. Click listeners are attached *dynamically* to each falling object when it's created.
    *   **Responsiveness (Basic):** The game container uses `max-w-lg` and `w-full` to adapt horizontally. The `aspect-ratio` helps maintain shape. A simple resize handler is added that ends the game if resized during play (a common simple solution).

4.  **User Experience:**
    *   Clear start/game over screens.
    *   Immediate score feedback.
    *   Objects are reasonably sized for clicking/tapping.
    *   `cursor: pointer` indicates objects are interactive.
    *   Slight scale animation on click (`:active` style).
    *   Difficulty increases gradually.
    *   Uses `requestAnimationFrame` for smoother animation.
    *   `touch-action: none` on the game area improves mobile experience by preventing scrolling.
    *   `overscroll-behavior: none` on the body prevents pull-to-refresh on mobile.
