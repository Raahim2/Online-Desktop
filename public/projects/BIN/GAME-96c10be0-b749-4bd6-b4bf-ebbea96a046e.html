
```html
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Minimalist Reaction Time Game</title>
<link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
<style>
  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    /* background-color: #f8f9fa;  Tailwind bg-gray-100 overrides this */
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    margin: 0;
  }

  .button-container {
    display: flex;
    justify-content: center;
    align-items: center;
    /* Added min-height to prevent layout shift when button hides */
    min-height: 50px; /* Adjust height based on button size */
  }

  .game-button {
    background-color: #66ccff; /* Light blue */
    color: white;
    padding: 1rem 2rem;
    border-radius: 0.5rem;
    border: none;
    font-size: 1.2rem;
    cursor: pointer;
    transition: background-color 0.3s ease;
    /* Tailwind 'hidden' class is used, so display: block isn't strictly needed here */
  }

  .game-button:hover {
    background-color: #46b2e0; /* Darker blue on hover */
  }

  .score-container {
    margin-top: 2rem;
    text-align: center;
  }

</style>
</head>
<body class="bg-gray-100">

<div class="container mx-auto p-8 text-center">
  <h1 class="text-3xl font-bold mb-4">Reaction Time</h1>
  <div class="button-container">
    <!-- Button starts hidden via Tailwind 'hidden' class -->
    <button id="gameButton" class="game-button hidden text-white">Click Me!</button>
  </div>
  <div class="score-container mt-8">
    <!-- Added labels for clarity -->
    <p>Current Score: <span id="score">0</span></p>
    <p>High Score: <span id="highScore">0</span></p>
    <!-- Optional: Display last reaction time -->
    <!-- <p>Last Reaction: <span id="lastReaction">-</span> s</p> -->
  </div>
</div>

<script>
  const gameButton = document.getElementById('gameButton');
  const scoreDisplay = document.getElementById('score');
  const highScoreDisplay = document.getElementById('highScore');
  // Optional: const lastReactionDisplay = document.getElementById('lastReaction');

  let score = 0;
  // Load high score from local storage or default to 0
  let highScore = localStorage.getItem('reactionGameHighScore') || 0;
  let startTime;
  let gameTimer; // Variable to hold the timeout ID

  // Function to get a random delay (1 to 4 seconds)
  function getRandomDelay() {
    return Math.random() * 3000 + 1000;
  }

  // Function to prepare the next round
  function prepareNextRound() {
    // Ensure button is hidden and reset its state
    gameButton.classList.add('hidden');
    gameButton.disabled = true; // Disable button while hidden
    // Reset start time to indicate button isn't ready
    startTime = null;
    // Optional: Visual cue for waiting state
    // gameButton.textContent = "Wait...";
    // gameButton.style.backgroundColor = '#cccccc'; // Grey out

    // Clear any existing timer
    clearTimeout(gameTimer);

    const delay = getRandomDelay();
    gameTimer = setTimeout(() => {
      // Make the button visible and ready
      gameButton.classList.remove('hidden');
      gameButton.disabled = false; // Enable button
      // Optional: Reset visual cue
      // gameButton.textContent = "Click Me!";
      // gameButton.style.backgroundColor = '#66ccff'; // Original color
      startTime = new Date().getTime(); // Record the start time *only* when button appears
    }, delay);
  }

  // Function to handle the button click
  function handleClick() {
    // Check if the button was actually ready (startTime is set)
    // If startTime is null or undefined, it means the button wasn't ready (e.g., clicked too early or double click)
    if (!startTime) {
        console.log("Button not ready yet or already clicked!");
        // Optional: Implement a penalty for clicking too early
        // score = 0; // Reset score
        // scoreDisplay.textContent = score;
        // clearTimeout(gameTimer); // Cancel the scheduled appearance
        // prepareNextRound(); // Start over
        return; // Ignore the click
    }

    const endTime = new Date().getTime();
    const reactionTime = (endTime - startTime) / 1000; // Reaction time in seconds

    // Button was successfully clicked, reset startTime to prevent multiple score increments from one appearance
    startTime = null;

    // Update score
    score++;
    scoreDisplay.textContent = score;

    // Update high score if current score is higher
    if (score > highScore) {
      highScore = score;
      highScoreDisplay.textContent = highScore;
      // Save high score to local storage for persistence
      localStorage.setItem('reactionGameHighScore', highScore);
    }

    // Optional: Display the reaction time
    // lastReactionDisplay.textContent = reactionTime.toFixed(3);
    console.log("Reaction Time: " + reactionTime.toFixed(3) + " seconds");

    // Prepare for the next round
    prepareNextRound();
  }

  // Initialize the game
  function initGame() {
    score = 0; // Reset score for a new game session
    scoreDisplay.textContent = score;
    highScoreDisplay.textContent = highScore; // Display loaded or default high score
    prepareNextRound(); // Start the first round
  }

  // Add event listener to the button
  gameButton.addEventListener('click', handleClick);

  // Start the game when the page loads
  initGame();
</script>

</body>
</html>
```

**Explanation of Changes Made in the Provided Code:**

1.  **Scoring Logic:** The original code reset the `score` to 0 inside the `startGame` function, which was called after every successful click. This meant the score could never increase beyond 1.
    *   **Fix:** I've restructured the logic. `score = 0;` is now only called in `initGame`, which runs once on page load (or could be triggered by a "Restart" button if added). The function that schedules the button appearance (`prepareNextRound`, renamed from your `startGame`) no longer resets the score.
2.  **High Score Persistence:** The original high score was lost on page refresh.
    *   **Fix:** Added `localStorage.getItem` to load the high score when the script starts and `localStorage.setItem` to save it whenever a new high score is achieved.
3.  **State Management (`startTime`):** Added logic to ensure the score is only incremented if the button was actually visible and ready (`startTime` is not null). `startTime` is reset to `null` immediately after a successful click to prevent issues with rapid clicks and to clearly define the state.
4.  **Clarity and Renaming:** Renamed `startGame` to `prepareNextRound` to better reflect its purpose (scheduling the next button appearance rather than resetting the entire game). Created a new `initGame` function for initial setup.
5.  **Button State:** Explicitly added `gameButton.disabled = true;` when the button is hidden/waiting and `gameButton.disabled = false;` when it appears. This prevents clicks while it's not supposed to be clickable.
6.  **Timer Management:** Added `clearTimeout(gameTimer)` in `prepareNextRound` to prevent potential issues if the function were called multiple times unexpectedly.
7.  **Optional Enhancements (Commented Out):**
    *   Added comments indicating where you could display the `lastReactionTime`.
    *   Added comments showing how you might change the button's text/color to indicate a "waiting" state.
    *   Added comments showing where you could implement a penalty for clicking too early (when `startTime` is null).
8.  **CSS:** Added a `min-height` to `.button-container` to reduce layout shift when the button appears/disappears.
