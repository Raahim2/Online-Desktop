<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Story Weaver</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for drag handle, connection points, and lines */
        .story-block {
            position: absolute;
            min-width: 200px;
            max-width: 300px;
            touch-action: none; /* Prevent default touch actions like scrolling */
        }
        .drag-handle {
            cursor: move;
        }
        .connection-point {
            position: absolute;
            width: 12px;
            height: 12px;
            background-color: #3b82f6; /* blue-500 */
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.1s ease-in-out;
        }
        .connection-point:hover {
            transform: scale(1.3);
        }
        .connection-point.top { top: -6px; left: 50%; transform: translateX(-50%); }
        .connection-point.bottom { bottom: -6px; left: 50%; transform: translateX(-50%); }
        .connection-point.left { left: -6px; top: 50%; transform: translateY(-50%); }
        .connection-point.right { right: -6px; top: 50%; transform: translateY(-50%); }

        #connector-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allow clicks to pass through to blocks */
            overflow: visible; /* Ensure lines aren't clipped */
        }
        .connector-line {
            stroke: #6b7280; /* gray-500 */
            stroke-width: 2;
            fill: none;
        }
        .connector-line.connecting {
             stroke: #2563eb; /* blue-600 */
             stroke-dasharray: 5, 5;
        }
        /* Hide scrollbars for workspace */
        #workspace {
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none;  /* IE and Edge */
        }
        #workspace::-webkit-scrollbar {
            display: none; /* Chrome, Safari, Opera */
        }
        /* Basic highlighting for play mode */
        .story-block.playing {
            cursor: pointer;
            border-color: #f59e0b; /* amber-500 */
        }
         .story-block.current-play {
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.5); /* blue-500 ring */
            border-color: #3b82f6; /* blue-500 */
        }
    </style>
</head>
<body class="bg-gray-100 font-sans flex flex-col h-screen overflow-hidden">

    <!-- Header -->
    <header class="bg-white shadow-md p-3 flex items-center justify-between flex-wrap gap-2">
        <h1 class="text-xl md:text-2xl font-bold text-gray-800">Interactive Story Weaver</h1>
        <div class="flex items-center gap-2 flex-wrap">
             <button id="add-block-btn" class="bg-green-500 hover:bg-green-600 text-white font-semibold py-1 px-3 md:py-2 md:px-4 rounded text-sm md:text-base shadow transition duration-150 ease-in-out">
                Add Block
            </button>
            <button id="save-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-semibold py-1 px-3 md:py-2 md:px-4 rounded text-sm md:text-base shadow transition duration-150 ease-in-out">
                Save
            </button>
            <label for="load-input" class="bg-yellow-500 hover:bg-yellow-600 text-white font-semibold py-1 px-3 md:py-2 md:px-4 rounded text-sm md:text-base shadow cursor-pointer transition duration-150 ease-in-out">
                Load
            </label>
            <input type="file" id="load-input" accept=".json" class="hidden">
             <button id="toggle-mode-btn" class="bg-purple-500 hover:bg-purple-600 text-white font-semibold py-1 px-3 md:py-2 md:px-4 rounded text-sm md:text-base shadow transition duration-150 ease-in-out">
                Play Mode
            </button>
             <button id="clear-btn" class="bg-red-500 hover:bg-red-600 text-white font-semibold py-1 px-3 md:py-2 md:px-4 rounded text-sm md:text-base shadow transition duration-150 ease-in-out">
                Clear All
            </button>
        </div>
    </header>

    <!-- Main Workspace -->
    <main class="flex-1 relative overflow-auto" id="workspace-container">
        <div id="workspace" class="relative w-[3000px] h-[3000px] bg-gray-50 overflow-hidden">
            <!-- SVG Layer for Connectors -->
            <svg id="connector-layer"></svg>

            <!-- Blocks Container -->
            <div id="blocks-container" class="absolute top-0 left-0 w-full h-full">
                <!-- Story blocks will be added here dynamically -->
                 <!-- Example Initial Block -->
                <div id="block-start" class="story-block bg-white rounded-lg shadow-lg border border-gray-300 p-4 flex flex-col gap-2" style="left: 50px; top: 50px;">
                    <div class="drag-handle bg-gray-200 p-1 rounded-t-md text-center text-xs font-semibold text-gray-600 cursor-move">DRAG ME</div>
                    <textarea class="story-text w-full h-24 border border-gray-200 rounded p-2 focus:ring-1 focus:ring-blue-500 focus:border-blue-500 resize-none text-sm" placeholder="Write your story segment here...">Start your story here...</textarea>
                    <div class="connection-points relative h-4"> <!-- Increased height for easier targeting -->
                        <div class="connection-point top" data-block-id="block-start" data-point-pos="top"></div>
                        <div class="connection-point bottom" data-block-id="block-start" data-point-pos="bottom"></div>
                        <div class="connection-point left" data-block-id="block-start" data-point-pos="left"></div>
                        <div class="connection-point right" data-block-id="block-start" data-point-pos="right"></div>
                    </div>
                    <button class="delete-block-btn absolute -top-2 -right-2 bg-red-500 text-white rounded-full w-5 h-5 flex items-center justify-center text-xs font-bold shadow hover:bg-red-600 transition duration-150">&times;</button>
                </div>
            </div>
        </div>
         <!-- Zoom Controls -->
        <div class="absolute bottom-4 right-4 flex flex-col gap-2">
            <button id="zoom-in-btn" class="bg-gray-700 hover:bg-gray-800 text-white rounded-full w-8 h-8 flex items-center justify-center shadow text-lg">+</button>
            <button id="zoom-out-btn" class="bg-gray-700 hover:bg-gray-800 text-white rounded-full w-8 h-8 flex items-center justify-center shadow text-lg">-</button>
            <button id="zoom-reset-btn" class="bg-gray-700 hover:bg-gray-800 text-white rounded-full w-8 h-8 flex items-center justify-center shadow text-xs">100%</button>
        </div>
    </main>

    <script>
        const workspace = document.getElementById('workspace');
        const workspaceContainer = document.getElementById('workspace-container');
        const blocksContainer = document.getElementById('blocks-container');
        const connectorLayer = document.getElementById('connector-layer');
        const addBlockBtn = document.getElementById('add-block-btn');
        const saveBtn = document.getElementById('save-btn');
        const loadInput = document.getElementById('load-input');
        const clearBtn = document.getElementById('clear-btn');
        const toggleModeBtn = document.getElementById('toggle-mode-btn');
        const zoomInBtn = document.getElementById('zoom-in-btn');
        const zoomOutBtn = document.getElementById('zoom-out-btn');
        const zoomResetBtn = document.getElementById('zoom-reset-btn');

        let blocks = {}; // Store block data { id: { x, y, text, connections: { pointPos: targetBlockId, ... } } }
        let connections = []; // Store connection data { fromId, fromPoint, toId, toPoint }
        let blockCounter = 1;
        let draggedElement = null;
        let offset = { x: 0, y: 0 };
        let isConnecting = false;
        let connectionStart = null; // { blockId, pointPos, element }
        let tempLine = null;
        let isPlayMode = false;
        let currentPlayBlockId = null;
        let scale = 1;
        let pan = { x: 0, y: 0 }; // Pan offset for the workspace itself
        let isPanning = false;
        let panStart = { x: 0, y: 0 };

        // --- Initialization ---
        function initialize() {
            loadFromLocalStorage(); // Try loading saved data first
            if (Object.keys(blocks).length === 0) {
                 // If nothing loaded, ensure the example block exists
                 const startBlock = document.getElementById('block-start');
                 if (startBlock) {
                    addBlockToData(startBlock);
                 } else {
                    // If even the example isn't there, create one
                    createNewBlock(50, 50, 'Start your story here...', 'block-start');
                 }
            }
            renderAllBlocks();
            renderAllConnections();
            setupEventListeners();
            updateWorkspaceTransform(); // Apply initial transform
            centerInitialView();
        }

        function centerInitialView() {
            const firstBlock = Object.values(blocks)[0];
            if (firstBlock) {
                const containerRect = workspaceContainer.getBoundingClientRect();
                pan.x = (containerRect.width / 2) - (firstBlock.x * scale) - (150 * scale); // Approx center of block
                pan.y = (containerRect.height / 2) - (firstBlock.y * scale) - (100 * scale);
                updateWorkspaceTransform();
            } else {
                 // Default pan if no blocks
                 const containerRect = workspaceContainer.getBoundingClientRect();
                 pan.x = containerRect.width / 2 - (workspace.offsetWidth * scale / 2);
                 pan.y = containerRect.height / 2 - (workspace.offsetHeight * scale / 2);
                 updateWorkspaceTransform();
            }
        }


        // --- Block Management ---
        function createBlockElement(id, x, y, text) {
            const block = document.createElement('div');
            block.id = id;
            block.className = 'story-block bg-white rounded-lg shadow-lg border border-gray-300 p-4 flex flex-col gap-2';
            block.style.left = `${x}px`;
            block.style.top = `${y}px`;

            block.innerHTML = `
                <div class="drag-handle bg-gray-200 p-1 rounded-t-md text-center text-xs font-semibold text-gray-600 cursor-move">DRAG ME</div>
                <textarea class="story-text w-full h-24 border border-gray-200 rounded p-2 focus:ring-1 focus:ring-blue-500 focus:border-blue-500 resize-none text-sm" placeholder="Write your story segment here...">${text}</textarea>
                <div class="connection-points relative h-4">
                    <div class="connection-point top" data-block-id="${id}" data-point-pos="top"></div>
                    <div class="connection-point bottom" data-block-id="${id}" data-point-pos="bottom"></div>
                    <div class="connection-point left" data-block-id="${id}" data-point-pos="left"></div>
                    <div class="connection-point right" data-block-id="${id}" data-point-pos="right"></div>
                </div>
                <button class="delete-block-btn absolute -top-2 -right-2 bg-red-500 text-white rounded-full w-5 h-5 flex items-center justify-center text-xs font-bold shadow hover:bg-red-600 transition duration-150">&times;</button>
            `;

            // Add event listeners for the new block
            const dragHandle = block.querySelector('.drag-handle');
            const textarea = block.querySelector('.story-text');
            const connectionPoints = block.querySelectorAll('.connection-point');
            const deleteBtn = block.querySelector('.delete-block-btn');

            if (!isPlayMode) {
                dragHandle.addEventListener('mousedown', startDrag);
                dragHandle.addEventListener('touchstart', startDrag, { passive: false }); // Use passive: false for touch events
                textarea.addEventListener('input', updateBlockText);
                connectionPoints.forEach(point => {
                    point.addEventListener('mousedown', startConnection);
                    point.addEventListener('mouseup', endConnection);
                });
                deleteBtn.addEventListener('click', deleteBlock);
            } else {
                 block.classList.add('playing');
                 block.addEventListener('click', handlePlayNavigation);
                 // Disable editing features in play mode
                 dragHandle.style.display = 'none';
                 textarea.readOnly = true;
                 connectionPoints.forEach(p => p.style.display = 'none');
                 deleteBtn.style.display = 'none';
            }


            return block;
        }

        function addBlockToData(blockElement) {
             const id = blockElement.id;
             if (!blocks[id]) { // Only add if it doesn't exist
                const x = parseInt(blockElement.style.left || '0', 10);
                const y = parseInt(blockElement.style.top || '0', 10);
                const text = blockElement.querySelector('.story-text').value;
                blocks[id] = { x, y, text, connections: {} }; // Initialize connections object
             }
        }

        function createNewBlock(x = 100, y = 100, text = '', id = null) {
            if (!id) {
                do {
                    id = `block-${blockCounter++}`;
                } while (blocks[id]); // Ensure unique ID
            }

            blocks[id] = { x, y, text, connections: {} };
            const blockElement = createBlockElement(id, x, y, text);
            blocksContainer.appendChild(blockElement);
            return blockElement;
        }

         function deleteBlock(event) {
            const blockElement = event.target.closest('.story-block');
            if (!blockElement) return;
            const blockId = blockElement.id;

            if (confirm(`Are you sure you want to delete block "${blocks[blockId]?.text.substring(0, 20)}..." and its connections?`)) {
                // Remove connections associated with this block
                connections = connections.filter(conn => conn.fromId !== blockId && conn.toId !== blockId);

                // Remove references from other blocks' connections
                Object.values(blocks).forEach(b => {
                    for (const pointPos in b.connections) {
                        if (b.connections[pointPos] === blockId) {
                            delete b.connections[pointPos];
                        }
                    }
                });


                // Remove block data and element
                delete blocks[blockId];
                blockElement.remove();
                renderAllConnections(); // Redraw connections
            }
        }

        function renderAllBlocks() {
            blocksContainer.innerHTML = ''; // Clear existing blocks in DOM
            Object.keys(blocks).forEach(id => {
                const blockData = blocks[id];
                const blockElement = createBlockElement(id, blockData.x, blockData.y, blockData.text);
                blocksContainer.appendChild(blockElement);
            });
             // Re-apply play mode styling if active
            if (isPlayMode) {
                document.querySelectorAll('.story-block').forEach(el => {
                    el.classList.add('playing');
                    if (el.id === currentPlayBlockId) {
                        el.classList.add('current-play');
                    }
                });
            }
        }

        function updateBlockText(event) {
            const textarea = event.target;
            const blockElement = textarea.closest('.story-block');
            if (blockElement && blocks[blockElement.id]) {
                blocks[blockElement.id].text = textarea.value;
            }
        }

        // --- Drag and Drop ---
        function startDrag(event) {
             if (isPlayMode) return; // Don't drag in play mode
             // Prevent starting drag on textarea or connection points
             if (event.target.tagName === 'TEXTAREA' || event.target.classList.contains('connection-point') || event.target.classList.contains('delete-block-btn')) {
                return;
             }

            draggedElement = event.target.closest('.story-block');
            if (!draggedElement) return;

            event.preventDefault(); // Prevent text selection during drag

            const eventPos = getEventPosition(event);
            const rect = draggedElement.getBoundingClientRect();
            const workspaceRect = workspace.getBoundingClientRect(); // Use workspace rect for relative positioning

            // Calculate offset relative to the scaled and panned workspace
            offset = {
                x: (eventPos.clientX - workspaceRect.left) / scale - blocks[draggedElement.id].x,
                y: (eventPos.clientY - workspaceRect.top) / scale - blocks[draggedElement.id].y
            };


            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', endDrag);
            document.addEventListener('touchmove', drag, { passive: false });
            document.addEventListener('touchend', endDrag);

            draggedElement.style.zIndex = 1000; // Bring to front
        }

        function drag(event) {
            if (!draggedElement || isPanning) return; // Don't drag if panning
            event.preventDefault();

            const eventPos = getEventPosition(event);
            const workspaceRect = workspace.getBoundingClientRect();

             // Calculate new position based on mouse/touch relative to the workspace container, adjusted for scale and pan
            let newX = (eventPos.clientX - workspaceRect.left) / scale - offset.x;
            let newY = (eventPos.clientY - workspaceRect.top) / scale - offset.y;

            // Optional: Constrain movement within workspace boundaries (consider padding)
            const blockRect = draggedElement.getBoundingClientRect();
            const blockWidth = blockRect.width / scale;
            const blockHeight = blockRect.height / scale;
            newX = Math.max(0, Math.min(newX, workspace.offsetWidth - blockWidth));
            newY = Math.max(0, Math.min(newY, workspace.offsetHeight - blockHeight));


            // Update block data
            blocks[draggedElement.id].x = newX;
            blocks[draggedElement.id].y = newY;

            // Update block element style
            draggedElement.style.left = `${newX}px`;
            draggedElement.style.top = `${newY}px`;

            // Update connections attached to this block
            renderAllConnections();
        }

        function endDrag() {
            if (draggedElement) {
                draggedElement.style.zIndex = ''; // Reset z-index
                // Ensure final position is saved (already done in drag)
            }
            draggedElement = null;
            document.removeEventListener('mousemove', drag);
            document.removeEventListener('mouseup', endDrag);
            document.removeEventListener('touchmove', drag);
            document.removeEventListener('touchend', endDrag);
        }

        // --- Connections ---
        function startConnection(event) {
             if (isPlayMode) return;
            event.stopPropagation(); // Prevent triggering block drag

            const pointElement = event.target;
            const blockId = pointElement.dataset.blockId;
            const pointPos = pointElement.dataset.pointPos;

            isConnecting = true;
            connectionStart = { blockId, pointPos, element: pointElement };

            // Create temporary line
            tempLine = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            tempLine.setAttribute('class', 'connector-line connecting');
            connectorLayer.appendChild(tempLine);

            // Update line on mouse move
            document.addEventListener('mousemove', updateTempLine);
            document.addEventListener('touchmove', updateTempLine, { passive: false }); // Handle touch move
            // Use mouseup on document to catch release outside a point
            document.addEventListener('mouseup', cancelConnection);
            document.addEventListener('touchend', cancelConnection); // Handle touch end
        }

         function updateTempLine(event) {
            if (!isConnecting || !tempLine || !connectionStart) return;
            event.preventDefault(); // Prevent scrolling on touch devices

            const startCoords = getPointCoordinates(connectionStart.blockId, connectionStart.pointPos);
            const eventPos = getEventPosition(event);
            const workspaceRect = workspace.getBoundingClientRect();

            // Calculate end coords based on cursor position relative to the SVG layer
            const endX = (eventPos.clientX - workspaceRect.left) / scale;
            const endY = (eventPos.clientY - workspaceRect.top) / scale;

            drawConnector(startCoords.x, startCoords.y, endX, endY, tempLine);
        }

        function endConnection(event) {
             if (isPlayMode || !isConnecting || !connectionStart) return;
            event.stopPropagation();

            const endPointElement = event.target;
            const endBlockId = endPointElement.dataset.blockId;
            const endPointPos = endPointElement.dataset.pointPos;

            // Prevent connecting a block to itself or connecting the same two points twice
            if (endBlockId !== connectionStart.blockId) {
                 // Check if this specific connection already exists (in either direction for simplicity)
                 const existing = connections.find(c =>
                    (c.fromId === connectionStart.blockId && c.fromPoint === connectionStart.pointPos && c.toId === endBlockId && c.toPoint === endPointPos) ||
                    (c.fromId === endBlockId && c.fromPoint === endPointPos && c.toId === connectionStart.blockId && c.toPoint === connectionStart.pointPos)
                 );

                 if (!existing) {
                    // Add connection data (store one way for simplicity in drawing)
                    connections.push({
                        fromId: connectionStart.blockId,
                        fromPoint: connectionStart.pointPos,
                        toId: endBlockId,
                        toPoint: endPointPos
                    });
                     // Also update block data for navigation reference (optional but useful)
                     // Store outgoing connection
                     if (!blocks[connectionStart.blockId].connections) blocks[connectionStart.blockId].connections = {};
                     blocks[connectionStart.blockId].connections[connectionStart.pointPos] = endBlockId;

                    renderAllConnections();
                 }
            }

            // Clean up temporary line and state
            cancelConnectionCleanup();
        }

        function cancelConnection(event) {
             // Only cancel if the mouseup/touchend didn't happen on a valid connection point
             if (isConnecting && (!event.target || !event.target.classList.contains('connection-point'))) {
                 cancelConnectionCleanup();
             }
             // If it did happen on a connection point, endConnection will handle cleanup.
        }

        function cancelConnectionCleanup() {
             if (tempLine) {
                tempLine.remove();
                tempLine = null;
            }
            isConnecting = false;
            connectionStart = null;
            document.removeEventListener('mousemove', updateTempLine);
            document.removeEventListener('mouseup', cancelConnection);
            document.removeEventListener('touchmove', updateTempLine);
            document.removeEventListener('touchend', cancelConnection);
        }

        function getPointCoordinates(blockId, pointPos) {
            const blockData = blocks[blockId];
            const blockElement = document.getElementById(blockId);
            if (!blockData || !blockElement) return { x: 0, y: 0 };

            const blockRect = blockElement.getBoundingClientRect(); // Use getBoundingClientRect relative to viewport
            const workspaceRect = workspace.getBoundingClientRect(); // Get workspace rect relative to viewport

             // Calculate position relative to the workspace div (top-left corner)
            const relativeX = (blockRect.left - workspaceRect.left) / scale;
            const relativeY = (blockRect.top - workspaceRect.top) / scale;
            const width = blockRect.width / scale;
            const height = blockRect.height / scale;


            let x = relativeX;
            let y = relativeY;

            switch (pointPos) {
                case 'top':
                    x += width / 2;
                    break;
                case 'bottom':
                    x += width / 2;
                    y += height;
                    break;
                case 'left':
                    y += height / 2;
                    break;
                case 'right':
                    x += width;
                    y += height / 2;
                    break;
            }
            return { x, y };
        }

        function drawConnector(x1, y1, x2, y2, pathElement = null) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            // Simple straight line for now
            // const pathData = `M ${x1} ${y1} L ${x2} ${y2}`;

            // Curved path (cubic Bezier) - looks nicer
            const curveFactor = 0.5; // Adjust for more/less curve
            const cp1x = x1 + dx * curveFactor;
            const cp1y = y1;
            const cp2x = x1 + dx * (1 - curveFactor);
            const cp2y = y2;
            const pathData = `M ${x1} ${y1} C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${x2} ${y2}`;


            if (pathElement) {
                pathElement.setAttribute('d', pathData);
                return pathElement;
            } else {
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', pathData);
                path.setAttribute('class', 'connector-line');
                return path;
            }
        }

        function renderAllConnections() {
            // Clear existing lines
            connectorLayer.innerHTML = '';

            connections.forEach(conn => {
                const startCoords = getPointCoordinates(conn.fromId, conn.fromPoint);
                const endCoords = getPointCoordinates(conn.toId, conn.toPoint);

                 // Check if coordinates are valid (blocks might have been deleted)
                 if (startCoords && endCoords && document.getElementById(conn.fromId) && document.getElementById(conn.toId)) {
                    const path = drawConnector(startCoords.x, startCoords.y, endCoords.x, endCoords.y);
                    connectorLayer.appendChild(path);
                 } else {
                     // Optional: Clean up orphaned connections if blocks are missing
                     // console.warn("Orphaned connection found:", conn);
                 }
            });
        }


        // --- Save/Load ---
        function getStoryData() {
            // Prune connections in block data before saving if they are redundant with the main connections array
            // Or ensure block data connections are the source of truth. Let's use the main `connections` array.
            const blocksToSave = {};
             Object.entries(blocks).forEach(([id, data]) => {
                blocksToSave[id] = { x: data.x, y: data.y, text: data.text }; // Only save essential data
             });

            return {
                blocks: blocksToSave,
                connections: connections,
                blockCounter: blockCounter // Save counter to avoid ID clashes
            };
        }

        function saveStory() {
            try {
                const storyData = getStoryData();
                const json = JSON.stringify(storyData, null, 2); // Pretty print JSON
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'storyweaver_save.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                console.log("Story saved successfully.");
                saveToLocalStorage(); // Also save to local storage for persistence
            } catch (error) {
                console.error("Error saving story:", error);
                alert("Failed to save story.");
            }
        }

         function saveToLocalStorage() {
             try {
                 const storyData = getStoryData();
                 localStorage.setItem('storyWeaverSave', JSON.stringify(storyData));
                 console.log("Story saved to local storage.");
             } catch (error) {
                 console.error("Error saving to local storage:", error);
             }
         }

        function loadStory(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const json = e.target.result;
                    loadData(JSON.parse(json));
                     saveToLocalStorage(); // Save the loaded file to local storage
                } catch (error) {
                    console.error("Error loading story:", error);
                    alert("Failed to load story. Ensure it's a valid JSON file.");
                } finally {
                     // Reset file input to allow loading the same file again
                     loadInput.value = null;
                }
            };
            reader.readAsText(file);
        }

         function loadFromLocalStorage() {
             const savedData = localStorage.getItem('storyWeaverSave');
             if (savedData) {
                 try {
                     console.log("Loading story from local storage.");
                     loadData(JSON.parse(savedData));
                     return true; // Indicate success
                 } catch (error) {
                     console.error("Error loading from local storage:", error);
                     localStorage.removeItem('storyWeaverSave'); // Clear corrupted data
                     return false;
                 }
             }
             return false; // No data found
         }

        function loadData(storyData) {
             if (!storyData || !storyData.blocks) {
                 console.error("Invalid story data format.");
                 return;
             }
            // Clear current state
            clearWorkspace(false); // Don't confirm when loading

            blocks = storyData.blocks || {};
            connections = storyData.connections || [];
            blockCounter = storyData.blockCounter || Math.max(0, ...Object.keys(blocks).map(id => parseInt(id.split('-')[1] || 0))) + 1; // Recalculate if needed

             // Rebuild block connection references from the connections array
             Object.values(blocks).forEach(b => b.connections = {}); // Clear old refs
             connections.forEach(conn => {
                 if (blocks[conn.fromId]) {
                     if (!blocks[conn.fromId].connections) blocks[conn.fromId].connections = {};
                     blocks[conn.fromId].connections[conn.fromPoint] = conn.toId;
                 }
             });

            renderAllBlocks();
            renderAllConnections();
            console.log("Story loaded.");
            centerInitialView(); // Center view after loading
        }

        function clearWorkspace(confirmUser = true) {
            if (confirmUser && !confirm("Are you sure you want to clear the entire workspace? This cannot be undone.")) {
                return;
            }
            blocks = {};
            connections = [];
            blockCounter = 1;
            blocksContainer.innerHTML = '';
            connectorLayer.innerHTML = '';
            currentPlayBlockId = null;
             if (isPlayMode) { // Exit play mode if active
                 togglePlayMode();
             }
             localStorage.removeItem('storyWeaverSave'); // Clear local storage too
             console.log("Workspace cleared.");
             // Optionally add back a default starting block
             createNewBlock(50, 50, 'Start here...');
             centerInitialView();
        }

        // --- Play Mode ---
        function togglePlayMode() {
            isPlayMode = !isPlayMode;
            toggleModeBtn.textContent = isPlayMode ? 'Edit Mode' : 'Play Mode';
            toggleModeBtn.classList.toggle('bg-purple-500', !isPlayMode);
            toggleModeBtn.classList.toggle('hover:bg-purple-600', !isPlayMode);
            toggleModeBtn.classList.toggle('bg-indigo-500', isPlayMode);
            toggleModeBtn.classList.toggle('hover:bg-indigo-600', isPlayMode);

            document.querySelectorAll('.story-block').forEach(blockEl => {
                const dragHandle = blockEl.querySelector('.drag-handle');
                const textarea = blockEl.querySelector('.story-text');
                const connectionPoints = blockEl.querySelectorAll('.connection-point');
                const deleteBtn = blockEl.querySelector('.delete-block-btn');

                if (isPlayMode) {
                    blockEl.classList.add('playing');
                    blockEl.addEventListener('click', handlePlayNavigation);
                    if (dragHandle) dragHandle.style.display = 'none';
                    if (textarea) textarea.readOnly = true;
                    connectionPoints.forEach(p => p.style.display = 'none');
                    if (deleteBtn) deleteBtn.style.display = 'none';
                    // Optionally highlight the first block
                    const firstBlockId = Object.keys(blocks)[0];
                    if (firstBlockId) {
                        setCurrentPlayBlock(firstBlockId);
                    }
                } else {
                    blockEl.classList.remove('playing', 'current-play');
                    blockEl.removeEventListener('click', handlePlayNavigation);
                    if (dragHandle) dragHandle.style.display = '';
                    if (textarea) textarea.readOnly = false;
                    connectionPoints.forEach(p => p.style.display = '');
                     if (deleteBtn) deleteBtn.style.display = '';
                    currentPlayBlockId = null; // Clear current play block when exiting mode
                }
            });

             // Disable/Enable other UI elements
             addBlockBtn.disabled = isPlayMode;
             saveBtn.disabled = isPlayMode;
             loadInput.disabled = isPlayMode;
             clearBtn.disabled = isPlayMode;
             loadInput.parentElement.classList.toggle('opacity-50', isPlayMode);
             loadInput.parentElement.classList.toggle('cursor-not-allowed', isPlayMode);
        }

        function setCurrentPlayBlock(blockId) {
            if (!isPlayMode || !blocks[blockId]) return;

            // Remove highlight from previous block
            if (currentPlayBlockId && document.getElementById(currentPlayBlockId)) {
                document.getElementById(currentPlayBlockId).classList.remove('current-play');
            }

            // Highlight new block
            currentPlayBlockId = blockId;
            const currentBlockElement = document.getElementById(currentPlayBlockId);
            if (currentBlockElement) {
                currentBlockElement.classList.add('current-play');
                 // Optional: Scroll block into view
                 // currentBlockElement.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });
                 centerViewOnBlock(blockId);
            }
        }

        function handlePlayNavigation(event) {
             if (!isPlayMode) return;
            const clickedBlockElement = event.currentTarget; // Use currentTarget as the listener is on the block
            const clickedBlockId = clickedBlockElement.id;

             // Allow clicking any block to make it the current one,
             // but only advance the story if clicking a *connected* block from the *current* one.
             // For now, let's just set the clicked block as current.
             // A more complex logic would involve checking connections from `currentPlayBlockId`.

            setCurrentPlayBlock(clickedBlockId);

             // --- Advanced Navigation Logic (Example - Needs Refinement) ---
             /*
             if (!currentPlayBlockId) { // If no block is current, make the clicked one current
                 setCurrentPlayBlock(clickedBlockId);
             } else if (clickedBlockId !== currentPlayBlockId) {
                 // Check if the clicked block is connected FROM the current block
                 const currentBlockData = blocks[currentPlayBlockId];
                 let isConnected = false;
                 if (currentBlockData && currentBlockData.connections) {
                     for (const pointPos in currentBlockData.connections) {
                         if (currentBlockData.connections[pointPos] === clickedBlockId) {
                             isConnected = true;
                             break;
                         }
                     }
                 }

                 if (isConnected) {
                     setCurrentPlayBlock(clickedBlockId);
                 } else {
                     // Optional: Provide feedback that the block is not connected
                     console.log("This block is not directly connected from the current one.");
                     // Or allow jumping to any block by clicking
                      setCurrentPlayBlock(clickedBlockId);
                 }
             }
             */
        }

        // --- Zooming and Panning ---
        function updateWorkspaceTransform() {
            workspace.style.transformOrigin = '0 0';
            workspace.style.transform = `translate(${pan.x}px, ${pan.y}px) scale(${scale})`;
            // Adjust SVG viewbox or redraw lines if necessary based on scale/pan - Redrawing is simpler here
            renderAllConnections();
        }

        function zoom(factor, clientX, clientY) {
            const workspaceRect = workspaceContainer.getBoundingClientRect(); // Use container for reference point

            // Calculate mouse position relative to the container
            const mouseX = clientX - workspaceRect.left;
            const mouseY = clientY - workspaceRect.top;

            // Calculate the point on the workspace being pointed at before zoom
            const pointX = (mouseX - pan.x) / scale;
            const pointY = (mouseY - pan.y) / scale;

            // Apply zoom
            scale *= factor;
            scale = Math.max(0.1, Math.min(scale, 3)); // Clamp scale

            // Calculate new pan to keep the pointed-at location stationary
            pan.x = mouseX - pointX * scale;
            pan.y = mouseY - pointY * scale;


            updateWorkspaceTransform();
        }

         function centerViewOnBlock(blockId) {
            const blockData = blocks[blockId];
            const blockElement = document.getElementById(blockId);
            if (!blockData || !blockElement) return;

            const containerRect = workspaceContainer.getBoundingClientRect();
            const blockWidth = blockElement.offsetWidth; // Use actual element width
            const blockHeight = blockElement.offsetHeight;

            // Target center of the screen
            const targetX = containerRect.width / 2;
            const targetY = containerRect.height / 2;

            // Calculate required pan to center the block
            // Center of block in workspace coords = blockData.x + blockWidth / 2
            // We want: targetX = pan.x + (blockData.x + blockWidth / 2) * scale
            pan.x = targetX - (blockData.x + blockWidth / 2) * scale;
            pan.y = targetY - (blockData.y + blockHeight / 2) * scale;

            updateWorkspaceTransform();
        }


        // --- Utility ---
        function getEventPosition(event) {
            if (event.touches && event.touches.length > 0) {
                return { clientX: event.touches[0].clientX, clientY: event.touches[0].clientY };
            } else if (event.changedTouches && event.changedTouches.length > 0) {
                // Use changedTouches for touchend events
                 return { clientX: event.changedTouches[0].clientX, clientY: event.changedTouches[0].clientY };
            }
            return { clientX: event.clientX, clientY: event.clientY };
        }

        // --- Event Listeners Setup ---
        function setupEventListeners() {
            addBlockBtn.addEventListener('click', () => {
                 // Add new block near the center of the current view
                 const containerRect = workspaceContainer.getBoundingClientRect();
                 const viewCenterX = (containerRect.width / 2 - pan.x) / scale;
                 const viewCenterY = (containerRect.height / 2 - pan.y) / scale;
                 createNewBlock(Math.max(0, viewCenterX - 100), Math.max(0, viewCenterY - 50), 'New Segment');
            });
            saveBtn.addEventListener('click', saveStory);
            loadInput.addEventListener('change', loadStory);
            clearBtn.addEventListener('click', () => clearWorkspace(true));
            toggleModeBtn.addEventListener('click', togglePlayMode);

            // Zoom listeners
            zoomInBtn.addEventListener('click', () => {
                const rect = workspaceContainer.getBoundingClientRect();
                zoom(1.2, rect.left + rect.width / 2, rect.top + rect.height / 2); // Zoom towards center
            });
            zoomOutBtn.addEventListener('click', () => {
                 const rect = workspaceContainer.getBoundingClientRect();
                 zoom(1 / 1.2, rect.left + rect.width / 2, rect.top + rect.height / 2); // Zoom out from center
            });
             zoomResetBtn.addEventListener('click', () => {
                 scale = 1;
                 centerInitialView(); // Recenter after resetting zoom
                 // pan = { x: 0, y: 0 }; // Reset pan too
                 // updateWorkspaceTransform();
             });
             workspaceContainer.addEventListener('wheel', (e) => {
                 e.preventDefault();
                 const delta = -Math.sign(e.deltaY);
                 const zoomFactor = delta > 0 ? 1.1 : 1 / 1.1;
                 zoom(zoomFactor, e.clientX, e.clientY);
             }, { passive: false });


            // Panning listeners on the container (background)
            workspaceContainer.addEventListener('mousedown', (e) => {
                 // Start panning only if clicking the background (not a block or button)
                 if (e.target === workspaceContainer || e.target === workspace || e.target === connectorLayer || e.target === blocksContainer) {
                     isPanning = true;
                     panStart = { x: e.clientX - pan.x, y: e.clientY - pan.y };
                     workspaceContainer.style.cursor = 'grabbing';
                     // Add move/up listeners to document to capture mouse outside container
                     document.addEventListener('mousemove', handlePanMove);
                     document.addEventListener('mouseup', handlePanEnd);
                 }
            });
             workspaceContainer.addEventListener('touchstart', (e) => {
                 if (e.touches.length === 1 && (e.target === workspaceContainer || e.target === workspace || e.target === connectorLayer || e.target === blocksContainer)) {
                     // Prevent default touch behavior like scrolling page
                     // e.preventDefault(); // Be careful with this, might prevent other touch interactions if not specific enough
                     isPanning = true;
                     const touch = e.touches[0];
                     panStart = { x: touch.clientX - pan.x, y: touch.clientY - pan.y };
                     // No cursor change needed for touch
                     document.addEventListener('touchmove', handlePanMove, { passive: false });
                     document.addEventListener('touchend', handlePanEnd);
                 }
             }, { passive: false }); // Use passive: false if preventDefault is needed inside handler

             function handlePanMove(e) {
                 if (!isPanning) return;
                 // Prevent dragging blocks while panning
                 if (draggedElement) endDrag();

                 e.preventDefault(); // Prevent text selection or other unwanted actions
                 const pos = getEventPosition(e);
                 pan.x = pos.clientX - panStart.x;
                 pan.y = pos.clientY - panStart.y;
                 updateWorkspaceTransform();
             }

             function handlePanEnd(e) {
                 if (isPanning) {
                     isPanning = false;
                     workspaceContainer.style.cursor = 'grab'; // Or default
                     document.removeEventListener('mousemove', handlePanMove);
                     document.removeEventListener('mouseup', handlePanEnd);
                     document.removeEventListener('touchmove', handlePanMove);
                     document.removeEventListener('touchend', handlePanEnd);
                 }
             }
             workspaceContainer.style.cursor = 'grab'; // Initial cursor for panning


            // Initial setup for existing blocks (if loaded from HTML/storage before JS runs fully)
            document.querySelectorAll('.story-block').forEach(blockEl => {
                 addBlockToData(blockEl); // Ensure initial blocks are in the data store
                 const dragHandle = blockEl.querySelector('.drag-handle');
                 const textarea = blockEl.querySelector('.story-text');
                 const connectionPoints = blockEl.querySelectorAll('.connection-point');
                 const deleteBtn = blockEl.querySelector('.delete-block-btn');

                 if (dragHandle) {
                    dragHandle.addEventListener('mousedown', startDrag);
                    dragHandle.addEventListener('touchstart', startDrag, { passive: false });
                 }
                 if (textarea) textarea.addEventListener('input', updateBlockText);
                 connectionPoints.forEach(point => {
                    point.addEventListener('mousedown', startConnection);
                    point.addEventListener('mouseup', endConnection);
                 });
                  if (deleteBtn) deleteBtn.addEventListener('click', deleteBlock);
            });

            // Re-render connections on window resize
            window.addEventListener('resize', () => {
                // Update connections immediately on resize
                renderAllConnections();
                // Optional: Recenter if needed, or adjust pan/scale based on resize logic
            });
        }

        // --- Start the application ---
        initialize();

    </script>

</body>
</html>