
**Key Features:**

1.  **Responsive Grid:** The puzzle and target grids adjust their size based on the viewport.
2.  **Shape Manipulation:** Click a shape, then click an adjacent empty cell to move it.
3.  **Target Pattern:** A clear display of the pattern you need to achieve.
4.  **Visual Feedback:**
    *   Gradient colors for shapes.
    *   Subtle hover effects on cells.
    *   Smooth transitions when shapes move.
    *   Highlighting of the selected shape.
5.  **Win Condition:** A message appears when the puzzle matches the target.
6.  **Reset Button:** Allows restarting the current puzzle.
7.  **Minimalist Design:** Clean UI leveraging Tailwind CSS utilities.
8.  **Vanilla JS:** No external JavaScript frameworks.
9.  **SVG Shapes:** Uses inline SVG for crisp and scalable shapes (specifically triangles).

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Abstract Grid Puzzle</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com?plugins=aspect-ratio"></script>
    <style>
        /* Custom styles for smoother transitions if needed */
        .puzzle-cell > div { /* Target shape divs */
            transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out;
        }
        .shape-enter {
            opacity: 0;
            transform: scale(0.5);
        }
        .shape-exit {
             opacity: 0;
             transform: scale(0.5);
        }
        /* Simple pulse for win message */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: .7; }
        }
        .animate-pulse-win {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
    </style>
</head>
<body class="bg-gradient-to-br from-gray-100 to-gray-300 min-h-screen flex flex-col items-center justify-center p-4 font-sans">

    <h1 class="text-3xl font-bold text-gray-700 mb-6">Abstract Shape Puzzle</h1>

    <div class="flex flex-col lg:flex-row items-center lg:items-start gap-8 w-full max-w-4xl">

        <!-- Target Pattern -->
        <div class="flex flex-col items-center">
            <h2 class="text-xl font-semibold text-gray-600 mb-3">Target Pattern</h2>
            <div id="target-grid" class="grid grid-cols-3 gap-1 p-1 bg-gray-400 rounded-md shadow-md">
                <!-- Target grid cells will be generated here -->
            </div>
        </div>

        <!-- Puzzle Grid -->
        <div class="flex flex-col items-center">
             <h2 class="text-xl font-semibold text-gray-600 mb-3">Your Puzzle</h2>
            <div id="puzzle-grid" class="grid grid-cols-3 gap-1 p-1 bg-white rounded-md shadow-lg cursor-pointer">
                <!-- Puzzle grid cells will be generated here -->
            </div>
            <div id="win-message" class="mt-4 text-center h-6">
                 <!-- Win message appears here -->
            </div>
        </div>

    </div>

     <!-- Controls -->
    <div class="mt-6">
        <button id="reset-button" class="bg-indigo-500 hover:bg-indigo-700 text-white font-bold py-2 px-5 rounded-lg shadow transition duration-150 ease-in-out focus:outline-none focus:ring-2 focus:ring-indigo-400 focus:ring-opacity-75">
            Reset Puzzle
        </button>
    </div>


    <script>
        const GRID_SIZE = 3;

        // --- Level Definition ---
        // Shape object: { type: 'square' | 'triangle', color: 'gradient-class', rotation: 0|90|180|270 }
        // null represents an empty cell
        const level1 = {
            targetState: [
                [ { type: 'square', color: 'bg-gradient-to-br from-cyan-400 to-blue-600', id: 'ts1' }, null, { type: 'triangle', color: 'bg-gradient-to-br from-emerald-400 to-green-600', rotation: 0, id: 'tt1' } ],
                [ null, { type: 'triangle', color: 'bg-gradient-to-br from-amber-400 to-orange-600', rotation: 180, id: 'tt2' }, null ],
                [ { type: 'square', color: 'bg-gradient-to-br from-rose-400 to-red-600', id: 'ts2' }, null, { type: 'square', color: 'bg-gradient-to-br from-violet-400 to-purple-600', id: 'ts3'} ]
            ],
            initialState: [
                [ null, { type: 'square', color: 'bg-gradient-to-br from-rose-400 to-red-600', id: 'ps2' }, null ],
                [ { type: 'triangle', color: 'bg-gradient-to-br from-emerald-400 to-green-600', rotation: 0, id: 'pt1' }, null, { type: 'square', color: 'bg-gradient-to-br from-cyan-400 to-blue-600', id: 'ps1' } ],
                [ { type: 'triangle', color: 'bg-gradient-to-br from-amber-400 to-orange-600', rotation: 180, id: 'pt2' }, { type: 'square', color: 'bg-gradient-to-br from-violet-400 to-purple-600', id: 'ps3'}, null ]
            ]
        };

        let currentLevel = level1;
        let currentPuzzleState = []; // Will be a deep copy of initialState
        let selectedCoords = null; // { row: r, col: c }
        let isGameWon = false;

        // DOM Elements
        const targetGridElement = document.getElementById('target-grid');
        const puzzleGridElement = document.getElementById('puzzle-grid');
        const resetButton = document.getElementById('reset-button');
        const winMessageElement = document.getElementById('win-message');

        // --- Helper Functions ---

        function deepCopyState(state) {
            return JSON.parse(JSON.stringify(state));
        }

        function areCoordsEqual(coords1, coords2) {
            if (!coords1 || !coords2) return false;
            return coords1.row === coords2.row && coords1.col === coords2.col;
        }

        function areAdjacent(coords1, coords2) {
            if (!coords1 || !coords2) return false;
            const rowDiff = Math.abs(coords1.row - coords2.row);
            const colDiff = Math.abs(coords1.col - coords2.col);
            return (rowDiff === 1 && colDiff === 0) || (rowDiff === 0 && colDiff === 1);
        }

        function getShapeElementId(shape) {
             // Use a consistent ID prefix if needed, otherwise rely on shape.id if provided
             return shape?.id || `shape-${Math.random().toString(36).substr(2, 9)}`;
        }

        function createShapeSvg(shape) {
            if (!shape) return '';

            const baseClasses = "w-full h-full object-contain transition-transform duration-300 ease-in-out";
            const transform = shape.rotation ? `transform: rotate(${shape.rotation}deg);` : '';

            if (shape.type === 'square') {
                return `<div id="${getShapeElementId(shape)}" class="${baseClasses} ${shape.color} rounded-sm" style="${transform}"></div>`;
            } else if (shape.type === 'triangle') {
                // Use SVG for triangles for easier rotation and crispness
                const gradientId = `grad-${shape.id || Math.random().toString(36).substr(2, 5)}`;
                const [fromColor, toColor] = shape.color.match(/from-([a-z]+)-(\d+)/)[0] && shape.color.match(/to-([a-z]+)-(\d+)/)[0]
                     ? [shape.color.match(/from-([a-z]+)-(\d+)/)[0].replace('from-',''), shape.color.match(/to-([a-z]+)-(\d+)/)[0].replace('to-','')]
                     : ['gray-500', 'gray-700']; // Fallback colors

                 // Extract Tailwind color names (this is imperfect, assumes standard format)
                 const fromColorName = shape.color.match(/from-([a-z]+)-/)?.[1] || 'gray';
                 const fromColorShade = shape.color.match(/from-[a-z]+-(\d+)/)?.[1] || '400';
                 const toColorName = shape.color.match(/to-([a-z]+)-/)?.[1] || 'gray';
                 const toColorShade = shape.color.match(/to-[a-z]+-(\d+)/)?.[1] || '600';

                // Define SVG gradient based on Tailwind class names (Approximation)
                // NOTE: This won't perfectly match Tailwind gradients but gives the idea.
                // A better approach might involve predefining SVG gradients or using CSS variables if Tailwind config was accessible.
                const svgGradient = `
                    <defs>
                        <linearGradient id="${gradientId}" x1="0%" y1="0%" x2="100%" y2="100%">
                            <stop offset="0%" style="stop-color:var(--color-${fromColorName}-${fromColorShade}, #ccc); stop-opacity:1" />
                            <stop offset="100%" style="stop-color:var(--color-${toColorName}-${toColorShade}, #333); stop-opacity:1" />
                        </linearGradient>
                    </defs>
                `;

                 // Basic upright triangle polygon
                return `
                    <svg id="${getShapeElementId(shape)}" viewBox="0 0 100 100" class="${baseClasses}" style="${transform}">
                         ${svgGradient}
                        <polygon points="50,15 85,85 15,85" fill="url(#${gradientId})" />
                    </svg>
                `;
            }
            return ''; // Should not happen
        }


        function renderGrid(gridElement, gridState, isInteractive) {
            gridElement.innerHTML = ''; // Clear previous content
            gridElement.style.gridTemplateColumns = `repeat(${GRID_SIZE}, minmax(0, 1fr))`; // Ensure correct columns

            gridState.forEach((row, r) => {
                row.forEach((cellShape, c) => {
                    const cell = document.createElement('div');
                    cell.classList.add(
                        'aspect-square', // Maintain square shape
                        'flex', 'items-center', 'justify-center',
                        'border', 'border-gray-300/50',
                        'rounded-sm', 'overflow-hidden',
                        'transition-colors', 'duration-150'
                    );
                    // Add hover effect only to interactive grid cells
                     cell.classList.add(isInteractive ? 'bg-gray-100 hover:bg-gray-200' : 'bg-gray-300/70');

                    cell.dataset.row = r;
                    cell.dataset.col = c;

                    if (cellShape) {
                        // Temporarily add shape for layout calculation, then animate entrance
                         const shapeElementHtml = createShapeSvg(cellShape);
                         cell.innerHTML = shapeElementHtml;
                         const shapeElement = cell.firstChild;
                         if(shapeElement && isInteractive) { // Only animate puzzle grid shapes
                            // shapeElement.classList.add('shape-enter');
                            // requestAnimationFrame(() => { // Ensure class is added after element is in DOM
                            //     shapeElement.classList.remove('shape-enter');
                            // });
                         }

                    } else {
                        cell.innerHTML = ''; // Ensure empty cells are visually empty
                    }

                    // Add click listener only to the interactive puzzle grid
                    if (isInteractive) {
                        cell.addEventListener('click', handleCellClick);
                    }

                    gridElement.appendChild(cell);
                });
            });
        }

        // --- Game Logic ---

        function handleCellClick(event) {
             if (isGameWon) return; // Don't allow moves after winning

            const cellElement = event.currentTarget;
            const row = parseInt(cellElement.dataset.row);
            const col = parseInt(cellElement.dataset.col);
            const clickedCoords = { row, col };
            const shapeInClickedCell = currentPuzzleState[row][col];

            // Clear previous selection highlight visually
            puzzleGridElement.querySelectorAll('.ring-2').forEach(el => el.classList.remove('ring-2', 'ring-offset-2', 'ring-yellow-500', 'z-10'));

            if (selectedCoords) {
                // Attempting to move the selected shape
                const shapeToMove = currentPuzzleState[selectedCoords.row][selectedCoords.col];

                if (shapeInClickedCell === null && areAdjacent(selectedCoords, clickedCoords)) {
                    // Valid move: Move shape to empty adjacent cell
                    currentPuzzleState[clickedCoords.row][clickedCoords.col] = shapeToMove;
                    currentPuzzleState[selectedCoords.row][selectedCoords.col] = null;

                    // Update only the two affected cells for smoother animation
                    updateCell(selectedCoords.row, selectedCoords.col);
                    updateCell(clickedCoords.row, clickedCoords.col);

                    selectedCoords = null; // Deselect after move
                    checkWinCondition();

                } else {
                     // Invalid move target or clicking non-empty cell, just deselect
                     selectedCoords = null;
                     // If the new click is on another shape, select that one immediately
                     if (shapeInClickedCell !== null) {
                         selectedCoords = clickedCoords;
                         highlightSelectedCell(cellElement);
                     }
                }
            } else {
                // No shape selected, try selecting one
                if (shapeInClickedCell !== null) {
                    selectedCoords = clickedCoords;
                    highlightSelectedCell(cellElement);
                }
            }
        }

         function updateCell(row, col) {
            const cellElement = puzzleGridElement.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            if (!cellElement) return;

            const cellShape = currentPuzzleState[row][col];
            // Animate removal if needed (more complex, requires tracking elements)
            // cellElement.innerHTML = ''; // Clear quickly

            // Animate entrance
            const shapeHtml = createShapeSvg(cellShape);
            cellElement.innerHTML = shapeHtml; // Add new shape HTML

            // Apply entrance animation if a shape was added
            // if (cellShape && cellElement.firstChild) {
            //     const shapeElement = cellElement.firstChild;
            //     shapeElement.classList.add('shape-enter');
            //     requestAnimationFrame(() => {
            //         shapeElement.classList.remove('shape-enter');
            //     });
            // }
        }


        function highlightSelectedCell(cellElement) {
            const shapeElement = cellElement.firstChild;
            if (shapeElement) {
                 shapeElement.classList.add('ring-2', 'ring-offset-2', 'ring-yellow-500', 'z-10');
            } else {
                 // Maybe highlight the empty cell border?
                 cellElement.classList.add('ring-2', 'ring-yellow-500'); // Highlight cell itself if empty selected (though shouldn't happen with current logic)
            }
        }

        function checkWinCondition() {
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const puzzleCell = currentPuzzleState[r][c];
                    const targetCell = currentLevel.targetState[r][c];

                    if (puzzleCell === null && targetCell === null) continue;
                    if (puzzleCell === null || targetCell === null) return false; // One is empty, other isn't

                    // Compare relevant properties (type, color, rotation)
                    if (puzzleCell.type !== targetCell.type ||
                        puzzleCell.color !== targetCell.color ||
                        puzzleCell.rotation !== targetCell.rotation) {
                        return false; // Mismatch found
                    }
                }
            }

            // If loop completes, it's a match!
            isGameWon = true;
            winMessageElement.innerHTML = `<span class="text-green-600 font-bold text-lg animate-pulse-win">You solved it!</span>`;
            puzzleGridElement.style.cursor = 'default'; // Remove pointer cursor

             // Optional: Remove selection highlight on win
             puzzleGridElement.querySelectorAll('.ring-2').forEach(el => el.classList.remove('ring-2', 'ring-offset-2', 'ring-yellow-500', 'z-10'));
             selectedCoords = null;

            return true;
        }

        function resetGame() {
            currentPuzzleState = deepCopyState(currentLevel.initialState);
            selectedCoords = null;
            isGameWon = false;
            winMessageElement.innerHTML = ''; // Clear win message
            puzzleGridElement.style.cursor = 'pointer'; // Restore cursor

            // Re-render the puzzle grid completely on reset
            renderGrid(puzzleGridElement, currentPuzzleState, true);
        }

        // --- Initialization ---

        function initGame() {
            // Set grid sizes using CSS variables if needed, or rely on Tailwind classes
            targetGridElement.style.gridTemplateColumns = `repeat(${GRID_SIZE}, minmax(0, 1fr))`;
            puzzleGridElement.style.gridTemplateColumns = `repeat(${GRID_SIZE}, minmax(0, 1fr))`;

            // Render Target Grid (non-interactive)
            renderGrid(targetGridElement, currentLevel.targetState, false);

            // Render Initial Puzzle Grid (interactive)
            resetGame(); // Use reset to set initial state and render

            // Add event listeners
            resetButton.addEventListener('click', resetGame);
        }

        // Start the game when the DOM is ready
        document.addEventListener('DOMContentLoaded', initGame);

    </script>

</body>
</html>
```

**Explanation:**

1.  **HTML Structure:**
    *   Sets up the basic page layout using Tailwind's flexbox utilities (`flex`, `flex-col`, `lg:flex-row`, `items-center`, `gap-8`).
    *   Includes placeholders (`div` with IDs) for the target grid (`target-grid`), puzzle grid (`puzzle-grid`), win message (`win-message`), and the reset button (`reset-button`).
    *   Links to the Tailwind CSS CDN.
    *   Includes minimal CSS within `<style>` tags for transitions on the shapes (`.puzzle-cell > div`).

2.  **Tailwind CSS:**
    *   Used extensively for layout, spacing (`p-4`, `mb-6`, `gap-8`), background colors (`bg-gradient-to-br`, `bg-gray-100`, etc.), borders (`border`), rounded corners (`rounded-md`, `rounded-lg`), shadows (`shadow-md`, `shadow-lg`), text styling (`text-3xl`, `font-bold`, `text-gray-700`), and button styling.
    *   `aspect-square` class (from the `@tailwindcss/aspect-ratio` plugin, included via CDN parameter) ensures grid cells remain square.
    *   `grid`, `grid-cols-3`, `gap-1` define the grid structure. Responsiveness could be added with `md:grid-cols-3` etc. if the base `grid-cols-3` wasn't sufficient.

3.  **Vanilla JavaScript:**
    *   **`GRID_SIZE` Constant:** Defines the dimensions of the grid.
    *   **`level1` Object:** Holds the `targetState` and `initialState` for the puzzle. Each state is a 2D array. Cells contain either `null` (empty) or a shape object `{ type, color, rotation, id }`. The `id` helps potentially track specific DOM elements if needed for complex animations, though it's mostly used here for SVG gradient IDs.
    *   **State Variables:** `currentPuzzleState`, `selectedCoords`, `isGameWon` track the game's current status. `currentPuzzleState` is initialized as a deep copy to prevent modifying the original `initialState`.
    *   **DOM References:** Gets references to the key HTML elements.
    *   **`deepCopyState`:** Utility to create a true copy of the state arrays.
    *   **`createShapeSvg`:** Generates the HTML string for a shape (a `div` for squares, an inline `SVG` for triangles). It applies the gradient background class and rotation. The SVG gradient definition is a simplified attempt to map Tailwind color names to SVG stops.
    *   **`renderGrid`:** Clears and populates a grid element (target or puzzle) based on the provided state array. It creates cell divs, applies styling, adds `data-row` and `data-col` attributes for identification, and inserts the shape HTML using `createShapeSvg`. It adds click listeners only for the *interactive* puzzle grid.
    *   **`handleCellClick`:** The core interaction logic.
        *   Checks if a shape is already selected (`selectedCoords`).
        *   If yes, checks if the clicked cell is empty and adjacent. If so, moves the shape data in `currentPuzzleState`, updates the two affected cells in the DOM using `updateCell`, deselects, and checks for a win.
        *   If no shape is selected, checks if the clicked cell contains a shape. If yes, selects it (`selectedCoords`) and highlights it.
        *   Handles deselection on invalid moves or re-clicking the selected shape.
    *   **`updateCell`:** Updates the `innerHTML` of a single cell. This is slightly better for animations than re-rendering the whole grid, although the current transition is CSS-based and applies broadly.
    *   **`highlightSelectedCell`:** Adds Tailwind's `ring` utility classes to visually indicate the selected shape.
    *   **`checkWinCondition`:** Compares `currentPuzzleState` cell-by-cell with `currentLevel.targetState`. It checks `type`, `color`, and `rotation`. If they match, sets `isGameWon`, displays the win message, and updates UI state.
    *   **`resetGame`:** Resets the `currentPuzzleState` to the level's `initialState`, clears selection and win message, and re-renders the puzzle grid.
    *   **`initGame`:** Sets up the initial grids by calling `renderGrid` for both target and puzzle, and attaches the event listener to the reset button.
    *   **`DOMContentLoaded`:** Ensures the script runs only after the HTML is fully loaded.

4.  **Animation/Feedback:**
    *   The CSS `.puzzle-cell > div { transition: ... }` makes the shapes smoothly change `transform` (like scale or position, though direct position isn't used here) and `opacity`.
    *   The `ring-2 ring-offset-2 ring-yellow-500` classes provide clear selection feedback.
    *   The win message has a subtle pulse animation (`animate-pulse-win`).
