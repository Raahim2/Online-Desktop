<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive CRT Terminal</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Minimal styles for effects not easily achievable with Tailwind */
        @keyframes flicker { /* Simple text/element flicker */
          0%, 100% { opacity: 1; }
          50% { opacity: 0.85; }
        }
        .animate-flicker {
          animation: flicker 0.15s infinite alternate;
        }

        @keyframes subtle-glitch { /* Subtle position/color shift */
            0% { transform: translate(0, 0); text-shadow: 1px 1px 0 rgba(0, 255, 0, 0.2); }
            25% { transform: translate(1px, -1px); text-shadow: -1px -1px 0 rgba(255, 0, 0, 0.2); }
            50% { transform: translate(-1px, 1px); text-shadow: 1px -1px 0 rgba(0, 0, 255, 0.2); }
            75% { transform: translate(-1px, -1px); text-shadow: -1px 1px 0 rgba(0, 255, 0, 0.2); }
            100% { transform: translate(0, 0); text-shadow: 1px 1px 0 rgba(0, 255, 0, 0.2); }
        }
        .animate-subtle-glitch {
            animation: subtle-glitch 0.3s infinite linear alternate-reverse;
        }

        .scanlines::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100%;
            height: 100%;
            /* Subtle horizontal lines */
            background: repeating-linear-gradient(
                to bottom,
                transparent,
                transparent 1px,
                rgba(0, 0, 0, 0.3) 1px,
                rgba(0, 0, 0, 0.3) 2px
            );
            z-index: 2; /* Above background, below text */
            pointer-events: none; /* Allow interaction with content below */
            animation: flicker 0.1s infinite; /* Subtle flicker for the scanlines */
        }

        /* Style the scrollbar for a more thematic look (optional, browser support varies) */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #1f2937; /* gray-800 */
        }
        ::-webkit-scrollbar-thumb {
            background: #4ade80; /* green-400 */
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #22c55e; /* green-500 */
        }
        /* Firefox scrollbar */
        * {
            scrollbar-width: thin;
            scrollbar-color: #4ade80 #1f2937;
        }

        /* Basic caret styling */
        .terminal-input:focus {
            outline: none;
        }
        .caret {
            display: inline-block;
            width: 9px; /* Adjust width as needed */
            height: 1.2em; /* Match line height */
            background-color: #4ade80; /* green-400 caret */
            margin-left: 4px;
            animation: blink 1s step-end infinite;
            box-shadow: 0 0 5px rgba(74, 222, 128, 0.7); /* Subtle glow */
        }
        @keyframes blink {
            from, to { background-color: transparent; box-shadow: none; }
            50% { background-color: #4ade80; box-shadow: 0 0 5px rgba(74, 222, 128, 0.7); } /* green-400 caret */
        }
    </style>
</head>
<body class="bg-black font-mono text-green-400 min-h-screen flex items-center justify-center p-2 sm:p-4 selection:bg-green-600 selection:text-black">

    <!-- Main Terminal Container -->
    <div id="terminal-container" class="w-full max-w-5xl h-[90vh] max-h-[700px] bg-gray-900 rounded-lg shadow-2xl shadow-green-500/40 overflow-hidden flex flex-col relative border-4 border-gray-700/80 cursor-text">

        <!-- CRT Effect Overlays -->
        <div class="absolute inset-0 overflow-hidden rounded-md pointer-events-none">
             <!-- Inner shadow for CRT depth -->
            <div class="absolute inset-0 rounded-md shadow-[inset_0_0_50px_rgba(0,0,0,0.8)] z-10"></div>
             <!-- Scanlines -->
            <div class="scanlines"></div>
             <!-- Vignette -->
            <div class="absolute inset-0 bg-gradient-radial from-transparent via-black/10 to-black/70 z-10"></div>
             <!-- Subtle curvature simulation (using pseudo-elements) -->
             <div class="absolute -inset-4 transform scale-105 bg-transparent border-[10px] border-transparent rounded-[20px] shadow-[0_0_100px_rgba(0,0,0,0.6)_inset] box-border z-0"></div>
        </div>


        <!-- Terminal Content Area -->
        <div id="terminal-output" class="flex-grow p-3 sm:p-4 overflow-y-auto z-20 relative text-sm md:text-base leading-relaxed space-y-1">
            <!-- Initial Boot Sequence (Static) -->
            <p>RetroTerm BIOS v1.337</p>
            <p>CPU: Emulated Quantum Entangler @ 1.21 GHz</p>
            <p>Memory Test: 1PB OK</p>
            <p>Initializing Warp Drive...</p>
            <p class="animate-flicker text-yellow-400">...</p>
            <p>Loading <span class="animate-subtle-glitch text-purple-400">GLITCH_OS</span> [Kernel v4.2.0-rc1]...</p>
            <p>[ <span class="text-yellow-400">OK</span> ] Started User Session Manager.</p>
            <p>[ <span class="text-yellow-400">OK</span> ] Network Configuration Initialized (eth0: 192.168.0.42).</p>
            <p>Welcome back, <span class="text-blue-400">User</span>.</p>
            <p>System Status: <span class="text-yellow-500">Nominal</span>. Glitches Detected: <span class="text-red-500">7</span></p>
            <p class="border-t border-dashed border-green-700/50 my-2"></p>
            <p>Enter 'help' for a list of simulated commands.</p>
            <br>
            <!-- Dynamic content will be added here -->
        </div>

        <!-- Input Area -->
        <div class="p-2 border-t border-green-700/50 bg-gray-800/60 flex items-center z-20 relative backdrop-blur-sm">
            <span class="text-green-400 mr-2 shrink-0">&gt;&gt;</span>
            <input type="text" id="terminal-input" class="terminal-input flex-grow bg-transparent text-green-300 border-none focus:ring-0 p-0 placeholder-green-700/50" autofocus autocomplete="off" spellcheck="false" placeholder="Enter command...">
            <span class="caret"></span>
        </div>

    </div>

    <script>
        const terminalOutput = document.getElementById('terminal-output');
        const terminalInput = document.getElementById('terminal-input');
        const terminalContainer = document.getElementById('terminal-container');
        let commandHistory = [];
        let historyIndex = -1;

        // Predefined commands simulation
        const commands = {
            'help': [
                'Available Commands:',
                '  <span class="text-yellow-300">help</span>       - Display this help message',
                '  <span class="text-yellow-300">clear</span>      - Clear the terminal screen',
                '  <span class="text-yellow-300">date</span>       - Display the current date/time',
                '  <span class="text-yellow-300">ls</span>         - List simulated files',
                '  <span class="text-yellow-300">cat [file]</span> - Display file content (e.g., cat readme.txt)',
                '  <span class="text-yellow-300">glitch</span>     - Induce a temporary visual anomaly',
                '  <span class="text-yellow-300">scan</span>       - Initiate system integrity scan',
                '  <span class="text-yellow-300">whoami</span>     - Display user information',
                '  <span class="text-yellow-300">neofetch</span>   - Display simulated system info',
                '  <span class="text-yellow-300">exit</span>       - Close the terminal (simulation)'
            ],
            'date': () => [`System Time: ${new Date().toUTCString()}`],
            'ls': () => [
                '<span class="text-blue-400">bin/</span>    <span class="text-purple-400">config.sys</span>   readme.txt',
                '<span class="text-blue-400">docs/</span>   <span class="text-red-500">corrupted.dat</span>  image.glitch'
            ],
            'cat': (args) => {
                const filename = args[0];
                if (filename === 'readme.txt') {
                    return [
                        'README.TXT:',
                        '--------------------------',
                        'Welcome to the RetroTerm simulation.',
                        'This is a demonstration of HTML, Tailwind CSS, and minimal JS',
                        'to create a CRT terminal effect with scanlines and glitch art.',
                        'Not all commands are real. Explore and have fun!',
                        'Use <span class="text-yellow-300">glitch</span> command for visual effect.'
                    ];
                } else if (filename === 'config.sys') {
                     return [
                        'DEVICE=C:\\DOS\\HIMEM.SYS',
                        'DEVICE=C:\\DOS\\EMM386.EXE NOEMS',
                        'BUFFERS=20',
                        'FILES=40',
                        'DOS=HIGH,UMB',
                        'STACKS=9,256'
                    ];
                } else if (filename === 'corrupted.dat') {
                    return ['<span class="text-red-500">Error reading file: corrupted.dat</span>', 'Data appears unreadable. Possible disk failure.'];
                } else if (filename === 'image.glitch') {
                    // Simulate displaying a glitchy image placeholder conceptually
                    const imgUrl = `https://via.placeholder.com/300x100/111827/FF00FF/?text=GLITCH+ART+PLACEHOLDER`; // Dark bg, magenta text
                    return [
                        'Displaying image.glitch (simulated):',
                        `<img src="${imgUrl}" alt="Glitch Art Placeholder" class="mt-2 border border-dashed border-red-500 p-1 opacity-80 animate-subtle-glitch">`,
                        '(Image rendering simulated within terminal text flow)'
                        ];
                } else if (filename) {
                    return [`cat: ${filename}: No such file or directory`];
                } else {
                    return ['cat: missing operand'];
                }
            },
            'glitch': () => {
                terminalContainer.classList.add('animate-subtle-glitch'); // Apply to container for wider effect
                setTimeout(() => terminalContainer.classList.remove('animate-subtle-glitch'), 700); // Glitch for 0.7s
                return ['<span class="text-red-500 animate-flicker">SYSTEM ANOMALY DETECTED... STABILIZING...</span>'];
            },
            'scan': () => [
                'Initiating system integrity scan...',
                'Scanning memory banks... <span class="text-green-300">OK</span>',
                'Verifying kernel modules... <span class="text-green-300">OK</span>',
                'Checking data streams... [<span class="text-red-500 animate-flicker">ERROR</span>] Data packet loss detected!',
                'Attempting recalibration...',
                'Scan complete. <span class="text-yellow-500">Warnings: 1</span>'
            ],
             'whoami': () => [
                'user: <span class="text-blue-400">guest</span>',
                'host: <span class="text-purple-400">retroterm-sim</span>',
                'tty:  /dev/pts/0'
            ],
            'neofetch': () => [ // Simplified neofetch-like output
                '        <span class="text-blue-400">.--.</span>     <span class="text-blue-400">guest</span>@<span class="text-purple-400">retroterm-sim</span>',
                '       <span class="text-blue-400">|o_o |</span>    -----------------',
                '       <span class="text-blue-400">|:_/ |</span>    <span class="text-gray-400">OS</span>: Glitch_OS (Simulated)',
                '      <span class="text-blue-400">//   \\ \\</span>   <span class="text-gray-400">Kernel</span>: 4.2.0-rc1-generic',
                '     <span class="text-blue-400">( \\_\\ )</span>   <span class="text-gray-400">Uptime</span>: 42 minutes',
                '     <span class="text-blue-400">\\_\\_\\/</span>    <span class="text-gray-400">Shell</span>: bash (simulated)',
                '      <span class="text-blue-400">__|| __</span>   <span class="text-gray-400">Terminal</span>: RetroTerm',
                '     <span class="text-blue-400">|| || \\</span>    <span class="text-gray-400">CPU</span>: Emulated Quantum Entangler',
                '    <span class="text-blue-400">|| ||</span>     <span class="text-gray-400">Memory</span>: 1PB (Virtual)',
                '   <span class="text-blue-400">_||_||_</span>    <span class="text-green-400">██</span><span class="text-yellow-400">██</span><span class="text-red-500">██</span><span class="text-blue-500">██</span><span class="text-purple-500">██</span><span class="text-cyan-500">██</span><span class="text-white">██</span><span class="text-gray-500">██</span>',
            ],
            'clear': () => {
                 terminalOutput.innerHTML = '<p>Terminal cleared.</p><br>'; // Reset content
                 return []; // No output text for 'clear' itself
            },
            'exit': () => {
                terminalOutput.innerHTML += '<p class="text-yellow-400">Closing terminal simulation...</p>';
                terminalInput.disabled = true;
                terminalInput.placeholder = "Session ended.";
                // Optional: Fade out or visually indicate closure
                terminalContainer.classList.add('opacity-50', 'transition-opacity', 'duration-1000');
                return [];
            }
        };

        terminalInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter' && !terminalInput.disabled) {
                const fullCommand = terminalInput.value.trim();
                const commandParts = fullCommand.split(' ');
                const command = commandParts[0].toLowerCase();
                const args = commandParts.slice(1);

                // Add command to history if it's not empty
                if (fullCommand) {
                    commandHistory.unshift(fullCommand); // Add to beginning
                    if (commandHistory.length > 50) { // Limit history size
                        commandHistory.pop();
                    }
                }
                historyIndex = -1; // Reset history navigation index

                // Echo the command
                const commandElement = document.createElement('p');
                // Sanitize input display slightly (prevent basic HTML injection in echo)
                const escapedCommand = fullCommand.replace(/</g, "&lt;").replace(/>/g, "&gt;");
                commandElement.innerHTML = `<span class="text-gray-500">&gt;&gt;</span> ${escapedCommand}`;
                terminalOutput.appendChild(commandElement);

                // Process the command
                if (command) {
                    const commandExecutor = commands[command];
                    if (commandExecutor) {
                        // Execute command (function or array)
                        const result = typeof commandExecutor === 'function' ? commandExecutor(args) : commandExecutor;
                        result.forEach(line => {
                            const lineElement = document.createElement('p');
                            lineElement.innerHTML = line; // Allow HTML in output for styling/images
                            terminalOutput.appendChild(lineElement);
                        });
                        // Special handling for clear after execution
                        if (command === 'clear') {
                            commands.clear(); // This resets innerHTML
                        }
                    } else {
                        const errorElement = document.createElement('p');
                        errorElement.innerHTML = `<span class="text-red-500">Command not found:</span> ${command}`;
                        terminalOutput.appendChild(errorElement);
                    }
                }

                 // Add a blank line for spacing before next prompt appears implicitly
                 const blankLine = document.createElement('br');
                 terminalOutput.appendChild(blankLine);

                // Clear the input
                terminalInput.value = '';

                // Scroll to the bottom
                terminalOutput.scrollTop = terminalOutput.scrollHeight;

                // Prevent default form submission behavior
                event.preventDefault();
            } else if (event.key === 'ArrowUp' && !terminalInput.disabled) {
                // Navigate command history (up)
                if (commandHistory.length > 0 && historyIndex < commandHistory.length - 1) {
                    historyIndex++;
                    terminalInput.value = commandHistory[historyIndex];
                    // Move cursor to end of input
                    setTimeout(() => terminalInput.selectionStart = terminalInput.selectionEnd = terminalInput.value.length, 0);
                }
                event.preventDefault();
            } else if (event.key === 'ArrowDown' && !terminalInput.disabled) {
                // Navigate command history (down)
                if (historyIndex > 0) {
                    historyIndex--;
                    terminalInput.value = commandHistory[historyIndex];
                     // Move cursor to end of input
                    setTimeout(() => terminalInput.selectionStart = terminalInput.selectionEnd = terminalInput.value.length, 0);
                } else if (historyIndex === 0) {
                    // Reached the end of history, clear input
                    historyIndex = -1;
                    terminalInput.value = '';
                }
                event.preventDefault();
            } else if (event.key === 'l' && event.ctrlKey) {
                // Ctrl+L shortcut for clear
                commands.clear();
                event.preventDefault();
            }
        });

         // Initial scroll to bottom if content overflows
         terminalOutput.scrollTop = terminalOutput.scrollHeight;

         // Focus input on click anywhere in terminal container (improves UX)
         terminalContainer.addEventListener('click', (event) => {
            // Only focus if the click wasn't on the input itself or a link/button inside output
            if (event.target === terminalContainer || event.target === terminalOutput) {
                 if (!terminalInput.disabled) {
                    terminalInput.focus();
                 }
            }
         });

         // Keep input focused
         terminalInput.addEventListener('blur', () => {
            // Re-focus unless the terminal is disabled (e.g., after 'exit')
             if (!terminalInput.disabled) {
                // Use a tiny delay to prevent issues with clicking scrollbars etc.
                // setTimeout(() => terminalInput.focus(), 10);
                // Re-focusing on blur can be annoying, let's keep it simple: focus on container click.
             }
         });

    </script>

</body>
</html>