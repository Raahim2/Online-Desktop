<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Constellation Creator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom scrollbar for better aesthetics in controls */
        .controls-scrollbar::-webkit-scrollbar {
            width: 6px;
        }
        .controls-scrollbar::-webkit-scrollbar-track {
            background: #1f2937; /* gray-800 */
            border-radius: 3px;
        }
        .controls-scrollbar::-webkit-scrollbar-thumb {
            background: #4b5563; /* gray-600 */
            border-radius: 3px;
        }
        .controls-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #6b7280; /* gray-500 */
        }
        /* Ensure canvas takes up available space */
        html, body {
            height: 100%;
            margin: 0;
            overflow: hidden; /* Prevent body scroll */
            background-color: #111827; /* bg-gray-900 */
        }
        #constellationCanvas {
            display: block; /* Remove extra space below canvas */
            background-color: transparent; /* Set by JS gradient */
        }
        .label-style {
            @apply block text-sm font-medium text-gray-300 mb-1;
        }
        .input-style {
            @apply w-full p-2 bg-gray-700 border border-gray-600 rounded-md text-white focus:ring-indigo-500 focus:border-indigo-500 text-sm;
        }
        .button-style {
            @apply w-full px-4 py-2 bg-indigo-600 text-white font-semibold rounded-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-800 focus:ring-indigo-500 transition duration-150 ease-in-out text-sm;
        }
        .toggle-button {
            @apply relative inline-flex items-center h-6 rounded-full w-11 transition-colors duration-200 ease-in-out focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-800 focus:ring-indigo-500;
        }
        .toggle-button span {
            @apply inline-block w-4 h-4 transform bg-white rounded-full transition-transform duration-200 ease-in-out;
        }
        .toggle-button[aria-checked="true"] {
            @apply bg-indigo-600;
        }
        .toggle-button[aria-checked="false"] {
            @apply bg-gray-600;
        }
        .toggle-button[aria-checked="true"] span {
            @apply translate-x-6;
        }
        .toggle-button[aria-checked="false"] span {
            @apply translate-x-1;
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col h-screen overflow-hidden">

    <header class="bg-gray-800 shadow-md py-3 px-4 md:px-6">
        <h1 class="text-xl md:text-2xl font-bold text-center text-indigo-300">Interactive Constellation Creator</h1>
    </header>

    <div class="flex flex-1 overflow-hidden">
        <!-- Canvas Area -->
        <main class="flex-1 relative bg-gray-900" id="canvas-container">
            <canvas id="constellationCanvas"></canvas>
        </main>

        <!-- Controls Sidebar -->
        <aside class="w-full md:w-72 lg:w-80 bg-gray-800 p-4 shadow-lg overflow-y-auto controls-scrollbar flex flex-col space-y-4 md:h-full md:max-h-[calc(100vh-60px)] /* Adjust based on header height */">

            <div class="space-y-3 border-b border-gray-700 pb-4">
                <h2 class="text-lg font-semibold text-indigo-300">Controls</h2>
                 <button id="randomStarsBtn" class="button-style">Generate Random Stars</button>
                 <button id="clearConnectionsBtn" class="button-style bg-red-600 hover:bg-red-700 focus:ring-red-500">Clear Connections</button>
            </div>

            <div class="space-y-3 border-b border-gray-700 pb-4">
                <h3 class="text-md font-semibold text-indigo-300">Star Appearance</h3>
                <div>
                    <label for="starSize" class="label-style">Star Size (<span id="starSizeValue">5</span>px)</label>
                    <input type="range" id="starSize" min="1" max="15" value="5" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer accent-indigo-500">
                </div>
                 <div>
                    <label for="starColor" class="label-style">Star Color</label>
                    <input type="color" id="starColor" value="#FFFFFF" class="input-style h-10 p-1">
                </div>
                <div class="flex items-center justify-between">
                     <label for="twinkleToggle" class="label-style mb-0">Twinkling Stars</label>
                     <button type="button" id="twinkleToggle" class="toggle-button" role="switch" aria-checked="true">
                         <span></span>
                     </button>
                </div>
            </div>

            <div class="space-y-3 border-b border-gray-700 pb-4">
                <h3 class="text-md font-semibold text-indigo-300">Night Sky</h3>
                <div>
                    <label for="backgroundGradient" class="label-style">Time of Night (<span id="backgroundGradientValue">50</span>%)</label>
                    <input type="range" id="backgroundGradient" min="0" max="100" value="50" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer accent-indigo-500">
                </div>
            </div>

            <div class="space-y-3">
                 <h3 class="text-md font-semibold text-indigo-300">Save & Load</h3>
                 <button id="saveBtn" class="button-style">Save Constellation</button>
                 <button id="loadBtn" class="button-style">Load Constellation</button>
                 <button id="deleteBtn" class="button-style bg-red-600 hover:bg-red-700 focus:ring-red-500">Delete Saved</button>
            </div>

            <div class="mt-auto pt-4 text-xs text-gray-500 text-center">
                Click stars to connect. Drag between stars.
            </div>
        </aside>
    </div>

    <script>
        const canvas = document.getElementById('constellationCanvas');
        const ctx = canvas.getContext('2d');
        const canvasContainer = document.getElementById('canvas-container');

        // --- State Variables ---
        let stars = [];
        let connections = [];
        let settings = {
            starSize: 5,
            starColor: '#FFFFFF',
            twinkling: true,
            backgroundGradientValue: 50, // 0 (midnight) to 100 (twilight)
        };

        let isDragging = false;
        let startStar = null;
        let currentMousePos = { x: 0, y: 0 };
        let selectedStar = null; // For visual feedback on hover/click

        // --- UI Elements ---
        const starSizeSlider = document.getElementById('starSize');
        const starSizeValueSpan = document.getElementById('starSizeValue');
        const starColorPicker = document.getElementById('starColor');
        const twinkleToggle = document.getElementById('twinkleToggle');
        const backgroundGradientSlider = document.getElementById('backgroundGradient');
        const backgroundGradientValueSpan = document.getElementById('backgroundGradientValue');
        const randomStarsBtn = document.getElementById('randomStarsBtn');
        const clearConnectionsBtn = document.getElementById('clearConnectionsBtn');
        const saveBtn = document.getElementById('saveBtn');
        const loadBtn = document.getElementById('loadBtn');
        const deleteBtn = document.getElementById('deleteBtn');

        // --- Initialization ---
        function init() {
            resizeCanvas();
            loadSettings(); // Load saved settings first
            loadConstellation(); // Attempt to load saved constellation
            if (stars.length === 0) {
                generateRandomStars(50); // Generate initial stars if none loaded
            }
            setupEventListeners();
            requestAnimationFrame(animationLoop);
        }

        function resizeCanvas() {
            canvas.width = canvasContainer.clientWidth;
            canvas.height = canvasContainer.clientHeight;
            // Regenerate stars if needed on resize or adjust positions? For now, just redraw.
            // Consider regenerating if aspect ratio changes significantly.
             if (stars.length > 0) { // Adjust existing star positions proportionally
                stars.forEach(star => {
                    star.x = star.x * (canvas.width / (star.canvasWidth || canvas.width));
                    star.y = star.y * (canvas.height / (star.canvasHeight || canvas.height));
                    star.canvasWidth = canvas.width; // Store canvas size at time of creation/adjustment
                    star.canvasHeight = canvas.height;
                });
            }
        }

        window.addEventListener('resize', resizeCanvas);

        // --- Drawing Functions ---
        function drawBackground() {
            const val = settings.backgroundGradientValue / 100; // Normalize 0-1
            let color1, color2;

            // Simple gradient: Midnight blue -> Deeper purple -> Lighter twilight blue/orange hint
            if (val < 0.33) { // Midnight to Deep Purple
                const t = val / 0.33;
                color1 = `rgb(${lerp(1, 17, t)}, ${lerp(5, 24, t)}, ${lerp(32, 63, t)})`; // Dark Blue to Dark Purple
                color2 = `rgb(${lerp(17, 40, t)}, ${lerp(24, 50, t)}, ${lerp(63, 90, t)})`; // Dark Purple to Mid Purple
            } else if (val < 0.66) { // Deep Purple to Twilight Blue
                const t = (val - 0.33) / 0.33;
                color1 = `rgb(${lerp(17, 49, t)}, ${lerp(24, 99, t)}, ${lerp(63, 152, t)})`; // Dark Purple to Sky Blue-ish
                color2 = `rgb(${lerp(40, 100, t)}, ${lerp(50, 120, t)}, ${lerp(90, 180, t)})`; // Mid Purple to Lighter Blue
            } else { // Twilight Blue to Orange hint
                const t = (val - 0.66) / 0.34;
                color1 = `rgb(${lerp(49, 234, t)}, ${lerp(99, 179, t)}, ${lerp(152, 8, t)})`; // Sky Blue-ish to Orange
                color2 = `rgb(${lerp(100, 253, t)}, ${lerp(120, 224, t)}, ${lerp(180, 100, t)})`; // Lighter Blue to Lighter Orange/Yellow
            }


            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, color1);
            gradient.addColorStop(1, color2);

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        function lerp(a, b, t) {
            return a + (b - a) * t;
        }


        function drawStars() {
            stars.forEach((star, index) => {
                ctx.beginPath();
                let size = star.size || settings.starSize;
                const color = star.color || settings.starColor;

                if (settings.twinkling) {
                    const twinkleFactor = Math.abs(Math.sin(Date.now() * 0.001 + star.twinkleOffset)); // Slow twinkle
                    size *= (0.7 + twinkleFactor * 0.6); // Vary size between 70% and 130%
                    ctx.globalAlpha = 0.6 + twinkleFactor * 0.4; // Vary alpha between 60% and 100%
                } else {
                     ctx.globalAlpha = 1.0;
                }

                ctx.arc(star.x, star.y, size, 0, Math.PI * 2);
                ctx.fillStyle = color;

                // Highlight selected star
                 if (selectedStar === index) {
                    ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
                    ctx.shadowBlur = 15;
                } else {
                    ctx.shadowColor = 'transparent';
                    ctx.shadowBlur = 0;
                }

                ctx.fill();
                ctx.shadowColor = 'transparent'; // Reset shadow
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1.0; // Reset alpha
            });
        }

        function drawConnections() {
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)'; // Connection line color
            ctx.lineWidth = 1.5;
            ctx.setLineDash([3, 3]); // Dashed lines for connections

            connections.forEach(conn => {
                const star1 = stars[conn.start];
                const star2 = stars[conn.end];
                if (star1 && star2) {
                    ctx.beginPath();
                    ctx.moveTo(star1.x, star1.y);
                    ctx.lineTo(star2.x, star2.y);
                    ctx.stroke();
                }
            });
            ctx.setLineDash([]); // Reset line dash
        }

        function drawDraggingLine() {
            if (isDragging && startStar !== null) {
                const startCoords = stars[startStar];
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(startCoords.x, startCoords.y);
                ctx.lineTo(currentMousePos.x, currentMousePos.y);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }

        // --- Interaction Logic ---
        function getMousePos(event) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: event.clientX - rect.left,
                y: event.clientY - rect.top
            };
        }

        function findStarAtPos(x, y) {
            const clickRadius = (settings.starSize * 1.5) + 5; // Generous click radius
            for (let i = stars.length - 1; i >= 0; i--) { // Iterate backwards to prioritize top stars
                const star = stars[i];
                const dx = x - star.x;
                const dy = y - star.y;
                if (dx * dx + dy * dy < clickRadius * clickRadius) {
                    return i; // Return index of the found star
                }
            }
            return null; // No star found
        }

        function handleMouseDown(event) {
            const pos = getMousePos(event);
            const clickedStarIndex = findStarAtPos(pos.x, pos.y);

            if (clickedStarIndex !== null) {
                isDragging = true;
                startStar = clickedStarIndex;
                selectedStar = clickedStarIndex; // Highlight clicked star
                currentMousePos = pos; // Initialize mouse pos for dragging line
            } else {
                isDragging = false;
                startStar = null;
                selectedStar = null; // Deselect if clicking empty space
            }
        }

        function handleMouseMove(event) {
            const pos = getMousePos(event);
            currentMousePos = pos; // Update for dragging line

            if (!isDragging) { // Handle hover effect only when not dragging
                 const hoveredStarIndex = findStarAtPos(pos.x, pos.y);
                 selectedStar = hoveredStarIndex; // Highlight star under cursor
            }
        }

        function handleMouseUp(event) {
            if (isDragging && startStar !== null) {
                const pos = getMousePos(event);
                const endStar = findStarAtPos(pos.x, pos.y);

                if (endStar !== null && endStar !== startStar) {
                    // Check if connection already exists (in either direction)
                    const exists = connections.some(conn =>
                        (conn.start === startStar && conn.end === endStar) ||
                        (conn.start === endStar && conn.end === startStar)
                    );
                    if (!exists) {
                        connections.push({ start: startStar, end: endStar });
                    }
                }
            }
            isDragging = false;
            startStar = null;
            // Keep selection on mouse up if over a star, otherwise clear
            const finalStar = findStarAtPos(currentMousePos.x, currentMousePos.y);
            selectedStar = finalStar;
        }

        function handleMouseLeave() {
             isDragging = false; // Stop dragging if mouse leaves canvas
             startStar = null;
             selectedStar = null; // Clear selection
        }


        // --- Data & Settings Management ---
        function generateRandomStars(count = 50) {
            stars = [];
            connections = []; // Clear connections when generating new stars
            const padding = 30; // Prevent stars too close to edge
            for (let i = 0; i < count; i++) {
                stars.push({
                    id: Date.now() + i, // Simple unique ID
                    x: Math.random() * (canvas.width - padding * 2) + padding,
                    y: Math.random() * (canvas.height - padding * 2) + padding,
                    size: settings.starSize + (Math.random() * 4 - 2), // Slight size variation
                    color: settings.starColor,
                    twinkleOffset: Math.random() * Math.PI * 2, // Random start phase for twinkle
                    canvasWidth: canvas.width, // Store canvas size for potential resizing logic
                    canvasHeight: canvas.height
                });
            }
        }

        function clearConnections() {
            connections = [];
        }

        function saveState() {
            try {
                const state = {
                    stars: stars,
                    connections: connections,
                    settings: settings
                };
                localStorage.setItem('constellationData', JSON.stringify(state));
                console.log('Constellation saved.');
                alert('Constellation saved successfully!');
            } catch (e) {
                console.error('Failed to save constellation:', e);
                alert('Error saving constellation. Local storage might be full or disabled.');
            }
        }

        function loadState() {
            try {
                const savedState = localStorage.getItem('constellationData');
                if (savedState) {
                    const state = JSON.parse(savedState);
                    stars = state.stars || [];
                    connections = state.connections || [];
                    // Only load settings if they exist in the saved data
                    if (state.settings) {
                         settings = { ...settings, ...state.settings }; // Merge, keeping defaults if needed
                    }
                    console.log('Constellation loaded.');
                    updateUIFromSettings(); // Reflect loaded settings in UI
                    resizeCanvas(); // Adjust star positions if canvas size changed since save
                    return true; // Indicate success
                }
            } catch (e) {
                console.error('Failed to load constellation:', e);
                alert('Error loading constellation data. It might be corrupted.');
            }
            return false; // Indicate failure or no data
        }

        function deleteSavedState() {
             if (confirm('Are you sure you want to delete the saved constellation? This cannot be undone.')) {
                try {
                    localStorage.removeItem('constellationData');
                    console.log('Saved constellation deleted.');
                    alert('Saved constellation deleted.');
                    // Optionally reset the current state to default after deletion
                    // settings = { ... }; // Reset settings to default
                    // generateRandomStars();
                    // updateUIFromSettings();
                } catch (e) {
                    console.error('Failed to delete saved data:', e);
                    alert('Error deleting saved data.');
                }
            }
        }

        function saveSettings() {
             try {
                 localStorage.setItem('constellationSettings', JSON.stringify(settings));
             } catch (e) {
                 console.warn('Could not save settings:', e);
             }
        }

        function loadSettings() {
            try {
                const savedSettings = localStorage.getItem('constellationSettings');
                if (savedSettings) {
                    const loaded = JSON.parse(savedSettings);
                    // Validate loaded settings if necessary
                    settings = { ...settings, ...loaded };
                    updateUIFromSettings();
                }
            } catch (e) {
                 console.warn('Could not load settings:', e);
            }
        }


        function updateUIFromSettings() {
            starSizeSlider.value = settings.starSize;
            starSizeValueSpan.textContent = settings.starSize;
            starColorPicker.value = settings.starColor;
            twinkleToggle.setAttribute('aria-checked', settings.twinkling);
            // Update toggle visual state
            const toggleSpan = twinkleToggle.querySelector('span');
             if (settings.twinkling) {
                 twinkleToggle.classList.add('bg-indigo-600');
                 twinkleToggle.classList.remove('bg-gray-600');
                 toggleSpan.style.transform = 'translateX(1.5rem)'; // Adjust based on your toggle size/styling (w-11 -> 6 * 0.25rem)
             } else {
                 twinkleToggle.classList.add('bg-gray-600');
                 twinkleToggle.classList.remove('bg-indigo-600');
                 toggleSpan.style.transform = 'translateX(0.25rem)'; // Adjust based on your toggle size/styling
             }
            backgroundGradientSlider.value = settings.backgroundGradientValue;
            backgroundGradientValueSpan.textContent = settings.backgroundGradientValue;
        }


        // --- Event Listeners Setup ---
        function setupEventListeners() {
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('mouseleave', handleMouseLeave); // Handle mouse leaving canvas

            starSizeSlider.addEventListener('input', (e) => {
                settings.starSize = parseInt(e.target.value, 10);
                starSizeValueSpan.textContent = settings.starSize;
                saveSettings();
            });

            starColorPicker.addEventListener('input', (e) => {
                settings.starColor = e.target.value;
                // Update existing stars immediately or only new ones? Let's update all for simplicity.
                stars.forEach(star => star.color = settings.starColor);
                saveSettings();
            });

             twinkleToggle.addEventListener('click', () => {
                 settings.twinkling = !settings.twinkling;
                 twinkleToggle.setAttribute('aria-checked', settings.twinkling);
                 // Update visual state (handled also in updateUIFromSettings)
                 const toggleSpan = twinkleToggle.querySelector('span');
                 if (settings.twinkling) {
                     twinkleToggle.classList.add('bg-indigo-600');
                     twinkleToggle.classList.remove('bg-gray-600');
                     toggleSpan.style.transform = 'translateX(1.5rem)';
                 } else {
                     twinkleToggle.classList.add('bg-gray-600');
                     twinkleToggle.classList.remove('bg-indigo-600');
                     toggleSpan.style.transform = 'translateX(0.25rem)';
                 }
                 saveSettings();
             });

            backgroundGradientSlider.addEventListener('input', (e) => {
                settings.backgroundGradientValue = parseInt(e.target.value, 10);
                backgroundGradientValueSpan.textContent = settings.backgroundGradientValue;
                saveSettings();
            });

            randomStarsBtn.addEventListener('click', () => {
                 if (confirm('Generate new random stars? This will clear current stars and connections.')) {
                    generateRandomStars(50);
                 }
            });
            clearConnectionsBtn.addEventListener('click', clearConnections);

            saveBtn.addEventListener('click', saveState);
            loadBtn.addEventListener('click', () => {
                if (localStorage.getItem('constellationData')) {
                    if (confirm('Load saved constellation? This will overwrite your current work.')) {
                        loadState();
                    }
                } else {
                    alert('No saved constellation found.');
                }
            });
             deleteBtn.addEventListener('click', deleteSavedState);
        }

        // --- Animation Loop ---
        function animationLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas

            drawBackground();
            drawConnections();
            drawStars();
            drawDraggingLine();

            requestAnimationFrame(animationLoop); // Request next frame
        }

        // --- Start the application ---
        document.addEventListener('DOMContentLoaded', init);

    </script>

</body>
</html>