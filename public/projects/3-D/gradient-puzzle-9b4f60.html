<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gradient Puzzle</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for drag feedback and tile appearance */
        .puzzle-tile {
            background-size: 300% 300%; /* Default, will be updated by JS */
            transition: transform 0.2s ease-in-out, opacity 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            cursor: grab;
            touch-action: none; /* Prevent scrolling on touch devices */
            box-shadow: inset 0 0 1px rgba(255, 255, 255, 0.3); /* Subtle inset border */
        }
        .puzzle-tile:active {
            cursor: grabbing;
            z-index: 10;
            transform: scale(1.05);
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
        }
        .dragging {
            opacity: 0.5;
            transform: scale(0.95);
        }
        .drag-over {
             /* Subtle visual cue for drop target */
            outline: 2px dashed rgba(255, 255, 255, 0.7);
            outline-offset: -2px;
            background-color: rgba(255, 255, 255, 0.1); /* Slight highlight */
        }
        .correct-placement {
             /* Optional: Add feedback for correctly placed tiles, maybe too revealing */
            /* border: 2px solid limegreen; */
        }
        #puzzle-grid {
            /* Ensure grid cells are square */
            aspect-ratio: 1 / 1;
            /* Prevent image dragging ghost */
            user-select: none;
            -webkit-user-drag: none;
        }
        #puzzle-container {
            position: relative;
        }
        #win-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s ease-in-out, visibility 0.5s ease-in-out;
            z-index: 20;
            border-radius: 0.5rem; /* Match grid rounding */
        }
        #win-overlay.show {
            opacity: 1;
            visibility: visible;
        }
        /* Style range input */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: #ddd;
            border-radius: 5px;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
        }
        input[type="range"]:hover {
            opacity: 1;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #4f46e5; /* Indigo */
            border-radius: 50%;
            cursor: pointer;
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #4f46e5; /* Indigo */
            border-radius: 50%;
            cursor: pointer;
            border: none; /* Remove default border in Firefox */
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 font-sans antialiased min-h-screen flex flex-col items-center p-4 md:p-8">

    <header class="text-center mb-6 md:mb-10">
        <h1 class="text-3xl sm:text-4xl md:text-5xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-purple-400 via-pink-500 to-red-500 mb-2">
            Gradient Puzzle
        </h1>
        <p class="text-gray-400 text-sm md:text-base">Rearrange the tiles to complete the gradient!</p>
    </header>

    <main class="w-full max-w-5xl flex flex-col lg:flex-row gap-8">

        <!-- Control Panel -->
        <aside class="w-full lg:w-1/3 xl:w-1/4 bg-gray-800 p-5 rounded-lg shadow-lg flex flex-col gap-6 order-2 lg:order-1">
            <h2 class="text-xl font-semibold border-b border-gray-700 pb-2">Controls</h2>

            <!-- Gradient Customization -->
            <div>
                <label class="block text-sm font-medium text-gray-300 mb-2">Gradient Colors</label>
                <div class="flex items-center justify-between gap-4">
                    <div class="flex items-center gap-2">
                        <label for="color1" class="sr-only">Start Color</label>
                        <input type="color" id="color1" value="#8B5CF6" class="w-10 h-10 rounded border border-gray-600 cursor-pointer bg-transparent">
                        <span class="text-xs text-gray-400">Start</span>
                    </div>
                     <div class="flex-grow h-2 rounded bg-gradient-to-r from-purple-500 to-pink-500" id="gradient-preview"></div>
                    <div class="flex items-center gap-2">
                         <span class="text-xs text-gray-400">End</span>
                        <label for="color2" class="sr-only">End Color</label>
                        <input type="color" id="color2" value="#EC4899" class="w-10 h-10 rounded border border-gray-600 cursor-pointer bg-transparent">
                    </div>
                </div>
            </div>

            <!-- Difficulty -->
            <div>
                <label for="difficulty" class="block text-sm font-medium text-gray-300 mb-2">Difficulty (Grid Size)</label>
                <div class="flex items-center gap-3">
                    <span class="text-gray-400 text-sm">3x3</span>
                    <input type="range" id="difficulty" min="3" max="7" value="3" step="1" class="w-full cursor-pointer">
                    <span class="text-gray-400 text-sm">7x7</span>
                </div>
                 <p class="text-center text-gray-400 text-sm mt-1">Current: <span id="difficulty-label">3</span> x <span id="difficulty-label2">3</span></p>
            </div>

            <!-- Shuffle Button -->
            <button id="shuffle-button" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded transition duration-150 ease-in-out focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 focus:ring-offset-gray-800">
                Shuffle Tiles
            </button>

             <!-- Reset Button -->
            <button id="reset-button" class="w-full bg-pink-600 hover:bg-pink-700 text-white font-bold py-2 px-4 rounded transition duration-150 ease-in-out focus:outline-none focus:ring-2 focus:ring-pink-500 focus:ring-offset-2 focus:ring-offset-gray-800">
                New Puzzle
            </button>
        </aside>

        <!-- Puzzle Area -->
        <section class="w-full lg:w-2/3 xl:w-3/4 flex-grow flex justify-center items-center order-1 lg:order-2">
            <div id="puzzle-container" class="w-full max-w-xl bg-gray-800 p-2 rounded-lg shadow-lg relative">
                 <div id="puzzle-grid" class="grid gap-1 rounded-md overflow-hidden">
                    <!-- Tiles will be generated here by JavaScript -->
                 </div>
                 <div id="win-overlay">
                     <div class="text-white p-6 rounded-lg bg-opacity-80 backdrop-blur-sm">
                         <h2 class="text-3xl font-bold mb-3 text-green-400">Congratulations!</h2>
                         <p class="text-lg mb-4">You solved the puzzle!</p>
                         <button id="play-again-button" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-5 rounded transition duration-150 ease-in-out focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 focus:ring-offset-gray-900">
                             Play Again
                         </button>
                     </div>
                 </div>
            </div>
        </section>

    </main>

    <footer class="mt-8 md:mt-12 text-center text-gray-500 text-xs">
        Gradient Puzzle &copy; 2023
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const puzzleGrid = document.getElementById('puzzle-grid');
            const puzzleContainer = document.getElementById('puzzle-container');
            const difficultySlider = document.getElementById('difficulty');
            const difficultyLabel = document.getElementById('difficulty-label');
            const difficultyLabel2 = document.getElementById('difficulty-label2');
            const shuffleButton = document.getElementById('shuffle-button');
            const resetButton = document.getElementById('reset-button');
            const color1Input = document.getElementById('color1');
            const color2Input = document.getElementById('color2');
            const gradientPreview = document.getElementById('gradient-preview');
            const winOverlay = document.getElementById('win-overlay');
            const playAgainButton = document.getElementById('play-again-button');

            let gridSize = parseInt(difficultySlider.value);
            let tiles = [];
            let draggedTile = null;
            let targetTile = null;
            let color1 = color1Input.value;
            let color2 = color2Input.value;
            let isSolved = false;

            function updateGradientPreview() {
                gradientPreview.style.background = `linear-gradient(to right, ${color1}, ${color2})`;
            }

            function createTiles() {
                puzzleGrid.innerHTML = ''; // Clear existing tiles
                tiles = [];
                isSolved = false;
                winOverlay.classList.remove('show');
                puzzleGrid.style.gridTemplateColumns = `repeat(${gridSize}, 1fr)`;
                puzzleGrid.style.setProperty('--grid-size', gridSize); // For potential CSS use

                const tileCount = gridSize * gridSize;
                const gradient = `linear-gradient(to bottom right, ${color1}, ${color2})`; // Gradient direction

                for (let i = 0; i < tileCount; i++) {
                    const tile = document.createElement('div');
                    tile.classList.add('puzzle-tile', 'w-full', 'h-full', 'bg-cover', 'bg-no-repeat');
                    tile.draggable = true;
                    tile.dataset.id = i; // Store original index/ID

                    const row = Math.floor(i / gridSize);
                    const col = i % gridSize;

                    // Calculate background position percentage
                    // Use (gridSize - 1) because there are gridSize-1 intervals between gridSize points
                    const bgPosX = (gridSize > 1) ? (col * 100 / (gridSize - 1)) : 0;
                    const bgPosY = (gridSize > 1) ? (row * 100 / (gridSize - 1)) : 0;

                    tile.style.backgroundImage = gradient;
                    tile.style.backgroundSize = `${gridSize * 100}% ${gridSize * 100}%`;
                    tile.style.backgroundPosition = `${bgPosX}% ${bgPosY}%`;

                    // Add event listeners
                    tile.addEventListener('dragstart', handleDragStart);
                    tile.addEventListener('dragover', handleDragOver);
                    tile.addEventListener('dragleave', handleDragLeave);
                    tile.addEventListener('drop', handleDrop);
                    tile.addEventListener('dragend', handleDragEnd);

                    // Touch events for mobile
                    tile.addEventListener('touchstart', handleTouchStart, { passive: false }); // Need passive:false to preventDefault
                    tile.addEventListener('touchmove', handleTouchMove, { passive: false });
                    tile.addEventListener('touchend', handleTouchEnd);


                    puzzleGrid.appendChild(tile);
                    tiles.push({
                        id: i,
                        element: tile,
                        originalIndex: i,
                        currentIndex: i // Initially same as original
                    });
                }
                 // Ensure container updates size if needed (esp. after grid size change)
                 puzzleContainer.style.width = 'auto'; // Reset width briefly
                 requestAnimationFrame(() => {
                    puzzleContainer.style.width = `${puzzleGrid.offsetWidth}px`;
                 });
            }

            function shuffleTiles() {
                isSolved = false;
                winOverlay.classList.remove('show');
                // Fisher-Yates (Knuth) Shuffle algorithm for DOM elements
                for (let i = puzzleGrid.children.length; i >= 0; i--) {
                    puzzleGrid.appendChild(puzzleGrid.children[Math.random() * i | 0]);
                }
                // Update the currentIndex in the tiles array based on new DOM order
                updateTileIndices();
            }

            function updateTileIndices() {
                 const currentTiles = Array.from(puzzleGrid.children);
                 tiles.forEach(tileData => {
                    const currentDOMIndex = currentTiles.indexOf(tileData.element);
                    tileData.currentIndex = currentDOMIndex;
                 });
            }

            function checkWinCondition() {
                if (isSolved) return; // Don't re-check if already solved

                for (let i = 0; i < tiles.length; i++) {
                    const tileElement = puzzleGrid.children[i];
                    const originalIndex = parseInt(tileElement.dataset.id);
                    if (i !== originalIndex) {
                        return false; // Not solved if any tile is out of place
                    }
                }

                console.log("Puzzle Solved!");
                isSolved = true;
                winOverlay.classList.add('show');
                // Optional: Make tiles undraggable when solved
                tiles.forEach(t => t.element.draggable = false);
                return true;
            }

            // --- Drag and Drop Event Handlers ---
            function handleDragStart(e) {
                if (isSolved) return;
                draggedTile = this;
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', this.dataset.id); // Can be useful
                setTimeout(() => this.classList.add('dragging'), 0); // Timeout ensures style applies after drag starts
            }

            function handleDragOver(e) {
                e.preventDefault(); // Necessary to allow dropping
                if (isSolved || this === draggedTile) return;
                this.classList.add('drag-over');
                e.dataTransfer.dropEffect = 'move';
                targetTile = this; // Keep track of potential drop target
            }

             function handleDragLeave(e) {
                if (this === targetTile) { // Only remove if leaving the current target
                    this.classList.remove('drag-over');
                    targetTile = null;
                }
            }

            function handleDrop(e) {
                e.preventDefault();
                e.stopPropagation(); // Prevent potential parent handlers
                if (isSolved || !draggedTile || this === draggedTile) {
                    if(this) this.classList.remove('drag-over'); // Clean up target style
                    return;
                }

                this.classList.remove('drag-over');

                // Swap the tiles in the DOM
                const draggedIndex = Array.from(puzzleGrid.children).indexOf(draggedTile);
                const targetIndex = Array.from(puzzleGrid.children).indexOf(this);

                // Simple DOM swap: Insert dragged before target, then insert target before original dragged position's next sibling
                // This handles edge cases better than just swapping innerHTML or direct node replacement
                 if (draggedIndex < targetIndex) {
                    puzzleGrid.insertBefore(draggedTile, this.nextSibling);
                    puzzleGrid.insertBefore(this, puzzleGrid.children[draggedIndex]);
                } else {
                    puzzleGrid.insertBefore(draggedTile, this);
                    puzzleGrid.insertBefore(this, puzzleGrid.children[draggedIndex + 1]);
                }


                updateTileIndices(); // Update internal state after DOM change
                checkWinCondition();
            }

            function handleDragEnd(e) {
                this.classList.remove('dragging');
                // Clean up any lingering drag-over styles if the drop didn't happen on a valid target
                Array.from(puzzleGrid.children).forEach(tile => tile.classList.remove('drag-over'));
                draggedTile = null;
                targetTile = null;
            }


            // --- Touch Event Handlers (Basic Implementation) ---
            let touchStartX = 0;
            let touchStartY = 0;
            let touchDraggedTile = null;
            let touchTargetTile = null;
            let initialScrollX = 0;
            let initialScrollY = 0;

            function handleTouchStart(e) {
                if (isSolved) return;
                // Prevent scrolling while dragging a tile
                e.preventDefault();

                touchDraggedTile = this;
                const touch = e.targetTouches[0];
                touchStartX = touch.clientX;
                touchStartY = touch.clientY;
                initialScrollX = window.scrollX;
                initialScrollY = window.scrollY;

                // Add visual feedback for touch dragging
                touchDraggedTile.style.zIndex = '10';
                touchDraggedTile.style.transform = 'scale(1.05)';
                touchDraggedTile.style.boxShadow = '0 10px 20px rgba(0,0,0,0.2)';
                touchDraggedTile.classList.add('dragging'); // Use similar visual cue
            }

            function handleTouchMove(e) {
                if (!touchDraggedTile || isSolved) return;
                // Prevent scrolling
                e.preventDefault();

                const touch = e.targetTouches[0];
                const currentX = touch.clientX;
                const currentY = touch.clientY;

                // Keep element visually under finger (adjust for initial scroll)
                const dx = currentX - touchStartX;
                const dy = currentY - touchStartY;
                touchDraggedTile.style.transform = `translate(${dx}px, ${dy}px) scale(1.05)`;

                // Find the element under the current touch position
                touchDraggedTile.style.visibility = 'hidden'; // Temporarily hide dragged element
                const elementUnderTouch = document.elementFromPoint(currentX, currentY);
                touchDraggedTile.style.visibility = 'visible'; // Make it visible again

                // Remove previous drag-over style
                if (touchTargetTile && touchTargetTile !== elementUnderTouch) {
                    touchTargetTile.classList.remove('drag-over');
                    touchTargetTile = null;
                }

                // Add drag-over style to new target if it's a valid puzzle tile
                if (elementUnderTouch && elementUnderTouch.classList.contains('puzzle-tile') && elementUnderTouch !== touchDraggedTile) {
                    touchTargetTile = elementUnderTouch;
                    touchTargetTile.classList.add('drag-over');
                }
            }

            function handleTouchEnd(e) {
                 if (!touchDraggedTile || isSolved) return;

                // Reset styles
                touchDraggedTile.style.zIndex = '';
                touchDraggedTile.style.transform = '';
                touchDraggedTile.style.boxShadow = '';
                touchDraggedTile.classList.remove('dragging');

                if (touchTargetTile) {
                    touchTargetTile.classList.remove('drag-over');

                    // Perform the swap (similar logic to drop)
                    const draggedIndex = Array.from(puzzleGrid.children).indexOf(touchDraggedTile);
                    const targetIndex = Array.from(puzzleGrid.children).indexOf(touchTargetTile);

                    if (draggedIndex < targetIndex) {
                        puzzleGrid.insertBefore(touchDraggedTile, touchTargetTile.nextSibling);
                        puzzleGrid.insertBefore(touchTargetTile, puzzleGrid.children[draggedIndex]);
                    } else {
                        puzzleGrid.insertBefore(touchDraggedTile, touchTargetTile);
                        puzzleGrid.insertBefore(touchTargetTile, puzzleGrid.children[draggedIndex + 1]);
                    }

                    updateTileIndices();
                    checkWinCondition();
                }

                // Clear touch state
                touchDraggedTile = null;
                touchTargetTile = null;
                touchStartX = 0;
                touchStartY = 0;
            }


            // --- Control Event Listeners ---
            difficultySlider.addEventListener('input', (e) => {
                const newSize = parseInt(e.target.value);
                difficultyLabel.textContent = newSize;
                difficultyLabel2.textContent = newSize;
            });

             difficultySlider.addEventListener('change', (e) => {
                gridSize = parseInt(e.target.value);
                createTiles(); // Recreate tiles with new size
                // Optionally shuffle immediately after changing difficulty
                // shuffleTiles();
            });

            shuffleButton.addEventListener('click', shuffleTiles);

            resetButton.addEventListener('click', () => {
                 createTiles(); // Recreate the puzzle with current settings
                 // shuffleTiles(); // Optionally shuffle on reset
            });

            color1Input.addEventListener('input', (e) => {
                color1 = e.target.value;
                updateGradientPreview();
                // Debounce or wait for change event if performance is an issue
                createTiles(); // Update tiles with new gradient
            });

            color2Input.addEventListener('input', (e) => {
                color2 = e.target.value;
                updateGradientPreview();
                createTiles(); // Update tiles with new gradient
            });

             playAgainButton.addEventListener('click', () => {
                winOverlay.classList.remove('show');
                shuffleTiles(); // Start a new game by shuffling
                // Or call createTiles() then shuffleTiles() if you want a completely new layout potentially
            });

            // --- Initial Setup ---
            difficultyLabel.textContent = gridSize;
            difficultyLabel2.textContent = gridSize;
            updateGradientPreview();
            createTiles();
            // Initial shuffle is often desired
            setTimeout(shuffleTiles, 100); // Short delay to ensure layout is stable

        });
    </script>

</body>
</html>